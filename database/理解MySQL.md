### MySQL 是怎样运行的：从根儿上理解 MySQL

```
来源：掘金小册《MySQL 是怎样运行的：从根儿上理解 MySQL》
作者：小孩子4919，公众号「我们都是小青蛙」作者
```

#### 1. 客户端连接

```
mysql -h127.0.0.1 -uroot -P3307 -p
```

**小贴士**： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除。

#### 2. MySQL 存储引擎

MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL 提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

| 存储引擎  | 描述                                 |
| --------- | ------------------------------------ |
| ARCHIVE   | 用于数据存档（行被插入后不能再修改） |
| BLACKHOLE | 丢弃写操作，读操作会返回空内容       |
| CSV       | 在存储数据时，以逗号分隔各个数据项   |
| FEDERATED | 用来访问远程表                       |
| InnoDB    | 具备外键支持功能的事务存储引擎       |
| MEMORY    | 置于内存的表                         |
| MERGE     | 用来管理多个 MyISAM 表构成的表集合   |
| MyISAM    | 主要的非事务处理存储引擎             |
| NDB       | MySQL 集群专用存储引擎               |

```
// 查看当前服务器程序支持的存储引擎
SHOW ENGINES;

// 创建表时指定存储引擎
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;

// 修改表的存储引擎
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

#### 3. 存储引擎的各种功能

| Feature                               | MyISAM | Memory  | InnoDB | Archive | NDB   |
| ------------------------------------- | ------ | ------- | ------ | ------- | ----- |
| B-tree indexes                        | yes    | yes     | yes    | no      | no    |
| Backup/point-in-time recovery         | yes    | yes     | yes    | yes     | yes   |
| Cluster database support              | no     | no      | no     | no      | yes   |
| Clustered indexes                     | no     | no      | yes    | no      | no    |
| Compressed data                       | yes    | no      | yes    | yes     | no    |
| **Data caches**                       | no     | N/A     | yes    | no      | yes   |
| Encrypted data                        | yes    | yes     | yes    | yes     | yes   |
| **Foreign key support**               | no     | no      | yes    | no      | yes   |
| Full-text search indexes              | yes    | no      | yes    | no      | no    |
| Geospatial data type support          | yes    | no      | yes    | yes     | yes   |
| Geospatial indexing support           | yes    | no      | yes    | no      | no    |
| **Hash indexes**                      | no     | yes     | no     | no      | yes   |
| Index caches                          | yes    | N/A     | yes    | no      | yes   |
| **Locking granularity**               | Table  | Table   | Row    | Row     | Row   |
| **MVCC**                              | no     | no      | yes    | no      | no    |
| Query cache support                   | yes    | yes     | yes    | yes     | yes   |
| Replication support                   | yes    | Limited | yes    | yes     | yes   |
| Storage limits                        | 256TB  | RAM     | 64TB   | None    | 384EB |
| T-tree indexes                        | no     | no      | no     | no      | yes   |
| **Transactions**                      | no     | no      | yes    | no      | yes   |
| Update statistics for data dictionary | yes    | yes     | yes    | yes     | yes   |

MyISAM（主要的非事务处理存储引擎）：支持全文索引；支持 GEO；表锁；

Memory（置于内存的表）：支持哈希索引；分片受限；表锁；

INNODB（具备外键支持功能的事务存储引擎）：唯一支持聚簇索引；支持数据缓存；支持外键；支持全文索引；支持 GEO；行锁；唯一支持 MVCC；支持事务；

Archive（用于数据存档（行被插入后不能再修改））：行锁；

NDB（MySQL 集群专用存储引擎）：唯一支持集群数据库；支持数据缓存；支持外键；支持哈希索引；唯一支持 T-树索引；支持事务；

MyISAM，Memory，INNODB 的相同点：都有 B-树索引；都有恢复点；都有数据加密；都支持查询缓存；

#### 4. 配置文件的优先级

MySQL 将按照给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。

值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准。

如果在同一个配置文件中，在这些组里出现了同样的配置项，那么，将以最后一个出现的组中的启动选项为准。

如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准！

配置是覆盖型的。

#### 5. 系统变量

系统变量比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。不过系统变量有作用范围之分，具体来说作用范围分为这两种：

GLOBAL：全局变量，影响服务器的整体操作。

SESSION：会话变量，影响某个客户端连接的操作。（注：SESSION 有个别名叫 LOCAL）

通过启动选项设置的系统变量的作用范围都是 GLOBAL 的，也就是对所有客户端都有效的。

在服务器程序运行期间通过客户端程序设置系统变量的语法：

```
SET [GLOBAL|SESSION] 系统变量名 = 值;
```

或者写成这样也行：

```
SET [@@(GLOBAL|SESSION).]var_name = XXX;
```

如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是 SESSION。也就是说 SET 系统变量名 = 值和 SET SESSION 系统变量名 = 值是等价的。

#### 6. 查看系统变量

我们可以使用下列命令查看 MySQL 服务器程序支持的系统变量以及它们的当前值：

```
SHOW VARIABLES [LIKE 匹配的模式];
```

由于系统变量实在太多了，如果我们直接使用 SHOW BLES 查看的话就直接刷屏了，所以通常都会带一个 LIKE 过滤条件来查看我们需要的系统变量的值。

既然系统变量有作用范围之分，那我们的 SHOW VARIABLES 语句查看的是什么作用范围的系统变量呢？

答：默认查看的是 SESSION 作用范围的系统变量。

当然我们也可以在查看系统变量的语句上加上要查看哪个作用范围的系统变量，就像这样：

```
SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];
```

#### 7. 状态变量

为了让我们更好的了解服务器程序的运行情况，MySQL 服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量。比方说 Threads_connected 表示当前有多少客户端与服务器建立了连接。

由于状态变量是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。

与系统变量类似，状态变量也有 GLOBAL 和 SESSION 两个作用范围的，所以查看状态变量的语句可以这么写：

```
SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];
```

#### 8. 一些重要的字符集

字符集指的是某个字符范围的编码规则。

比较规则是针对某个字符集中的字符比较大小的一种规则。

在 MySQL 中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个字符集。

查看 MySQL 中查看支持的字符集和比较规则的语句如下：

```
SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
SHOW COLLATION [LIKE 匹配的模式];
```

MySQL 有四个级别的字符集和比较规则:服务器级别，数据库级别，表级别，列级别

| 字符集     | 字符个数             | 字节数 | 备注                       |
| ---------- | -------------------- | ------ | -------------------------- |
| ASCII      | 128                  | 1      |                            |
| ISO 8859-1 | 256                  | 1      | 别名 latin1，兼容 ASCII    |
| GB2312     | 7445=6763+682        | 1 或 2 | 兼容 ASCII 时，使用 1 字节 |
| GBK        | GB2312 扩充          | 1 或 2 | 兼容 GB2312                |
| utf8       | 所有字符             | 1 ～ 4 | 变长编码                   |
| utf16      | 所有字符             | 2 或 4 | 变长编码                   |
| utf32      | 所有字符             | 4      |                            |
| utf8mb3    | 阉割过的 utf8 字符集 | 1 ～ 3 | MySQL 中字符集             |
| utf8mb4    | 正宗的 utf8 字符集   | 1 ～ 4 | MySQL 中字符集             |

有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使用 1~3 个字节来表示一个字符，如果大家有使用 4 字节编码一个字符的情况，比如存储一些 emoji 表情啥的，那请使用 utf8mb4。

#### 9. MySQL 中字符集的转换

从发送请求到接收结果过程中发生的字符集转换：

（1）客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。

（2）服务器将客户端发送来的字节串采用 character_set_client 代表的字符集进行解码，将解码后的字符串再按照 character_set_connection 代表的字符集进行编码。

（3）如果 character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从 character_set_connection 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。

（4）将从某个列获取到的字节串从该列使用的字符集转换为 character_set_results 代表的字符集后发送到客户端。

（5）客户端使用操作系统的字符集解析收到的结果集字节串。

character_set_client，服务器解码请求时使用的字符集。服务器认为客户端发送过来的请求是用 character_set_client 编码的。假设你的客户端采用的字符集和 character_set_client 不一样的话，这就会出现意想不到的情况。

character_set_connection，服务器处理请求时会把请求字符串从 character_set_client 转为 character_set_connection。character_set_connection 只是服务器在将请求的字节串从 character_set_client 转换为 character_set_connection 时使用，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求中的字符，要不然会导致有的字符无法使用 character_set_connection 代表的字符集进行编码。

character_set_results，服务器向客户端返回数据时使用的字符集。服务器将把得到的结果集使用 character_set_results 编码后发送给客户端。假设你的客户端采用的字符集和 character_set_results 不一样的话，这就可能会出现客户端无法解码结果集的情况。

我们通常都把 character_set_client 、character_set_connection、character_set_results 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，MySQL 提供了一条非常简便的语句：

```
SET NAMES 字符集名;
```

这一条语句产生的效果和我们执行这 3 条的效果是一样的：

```
SET character_set_client = 字符集名;
SET character_set_connection = 字符集名;
SET character_set_results = 字符集名;
```

#### 10. InnoDB 页

当我们想从表中获取某些记录时，InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？

不，那样会慢死，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位。

InnoDB 数据页的 7 个组成部分，知道了各个数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

#### 11. InnoDB 行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。

InnoDB 存储引擎有 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。

行溢出：一个页一般是 16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。

那发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？
MySQL 中规定一个页中至少存放两行记录。你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列。

（1）COMPACT 行格式：一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。
（1-1）记录的额外信息：这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为 3 类，分别是变长字段长度列表、NULL 值列表和记录头信息。
（1-1-1）变长字段长度列表：在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！变长字段长度列表中只存储值为 非 NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的。
（1-1-2）NULL 值列表：如果表中没有允许存储 NULL 的列，则 NULL 值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：二进制位的值为 1 时，代表该列的值为 NULL。二进制位的值为 0 时，代表该列的值不为 NULL。
（1-1-3）记录头信息：除了变长字段长度列表、NULL 值列表之外，还有一个用于描述记录的记录头信息，它是由固定的 5 个字节组成。5 个字节也就是 40 个二进制位，不同的位代表不同的意思。
（1-2）记录的真实数据：记录的真实数据除了我们自己定义的列的数据以外，MySQL 会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：

| 列名        | 是否必须 | 占用空间 | 描述                    |
| ----------- | -------- | -------- | ----------------------- |
| DB_ROW_ID   | 否       | 6 字节   | 行 ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6 字节   | 事务 ID                 |
| DB_ROLL_PTR | 是       | 7 字节   | 回滚指针                |

**InnoDB 表对主键的生成策略**

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。

注意：对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

（2）Redundant 行格式：其实知道了 Compact 行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的 Redundant 行格式是 MySQL5.0 之前用的一种行格式，也就是说它已经非常老了。下边我们从各个方面看一下 Redundant 行格式有什么不同的地方：
（2.1）字段长度偏移列表。没有了变长两个字，意味着 Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。多了个偏移两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。因为 Redundant 行格式并没有 NULL 值列表，所以在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为 NULL 的依据，该比特位也可以被称之为 NULL 比特位。
（2.2）记录头信息。Redundant 行格式的记录头信息占用 6 字节，48 个二进制位。

对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出 768 字节的那些页面也被称为溢出页。

（3&4）Dynamic 和 Compressed 行格式。这两种行格式类似于 COMPACT 行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。另外，Compressed 行格式会采用压缩算法对页面进行压缩。

指定行格式的语法

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

在 mysql 中查询表的详细信息如下

```
use 库名
show table status like '表名';
```

MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

#### 12. 数据页结构

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能。

一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

| 名称               | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------ | ------------------ | ------------ | ------------------------ |
| File Header        | 文件头部           | 38 字节      | 页的一些通用信息         |
| Page Header        | 页面头部           | 56 字节      | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26 字节      | 两个虚拟的行记录         |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8 字节       | 校验页是否完整           |

#### 13. 记录头信息

为了更好的管理在 User Records 中的这些记录，InnoDB 可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在 User Records 部分么？其实这话还得从记录行格式的记录头信息中说起。

| 名称         | 大小（单位：bit） | 描述                                                                                        |
| ------------ | ----------------- | ------------------------------------------------------------------------------------------- |
| 预留位 1     | 1                 | 没有使用                                                                                    |
| 预留位 2     | 1                 | 没有使用                                                                                    |
| delete_mask  | 1                 | 标记该记录是否被删除                                                                        |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记                                              |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                                                    |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                                                              |
| record_type  | 3                 | 表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶节点记录，2 表示最小记录，3 表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                                                    |

- delete_mask

这个属性标记着当前记录是否被删除，占用 1 个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时候代表记录被删除掉了。

这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- record_type

这个属性表示当前记录的类型，一共有 4 种类型的记录，0 表示普通记录，1 表示 B+树非叶节点记录，2 表示最小记录，3 表示最大记录。我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。

- next_record

这玩意儿非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。

如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。

但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录（也就是最大记录） 。

不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

**小贴士**： 你会不会觉得 next_record 这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？

因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL 值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。

**小贴士**： 当数据页中存在多条被删除掉的记录时，这些记录的 next_record 属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

#### 14. Page Directory（页目录）

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计 InnoDB 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

（1）将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

（2）每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

（3）将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的 Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。

对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。所以分组是按照下边的步骤进行的：

（1）初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。

（2）之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。

（3）在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。

通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

#### 15. Page Header（页面头部）

设计 InnoDB 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

| 名称              | 占用空间大小 | 描述                                                                            |
| ----------------- | ------------ | ------------------------------------------------------------------------------- |
| PAGE_N_DIR_SLOTS  | 2 字节       | 在页目录中的槽数量                                                              |
| PAGE_HEAP_TOP     | 2 字节       | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space                     |
| PAGE_N_HEAP       | 2 字节       | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）                    |
| PAGE_FREE         | 2 字节       | 第一个已经标记为删除的记录地址，其他删除的通过 next_record 形成单链表，可被重用 |
| PAGE_GARBAGE      | 2 字节       | 已删除记录占用的字节数                                                          |
| PAGE_LAST_INSERT  | 2 字节       | 最后插入记录的位置                                                              |
| PAGE_DIRECTION    | 2 字节       | 记录插入的方向                                                                  |
| PAGE_N_DIRECTION  | 2 字节       | 一个方向连续插入的记录数量                                                      |
| PAGE_N_RECS       | 2 字节       | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）                  |
| PAGE_MAX_TRX_ID   | 8 字节       | 修改当前页的最大事务 ID，该值仅在二级索引中定义                                 |
| PAGE_LEVEL        | 2 字节       | 当前页在 B+树中所处的层级                                                       |
| PAGE_INDEX_ID     | 8 字节       | 索引 ID，表示当前页属于哪个索引                                                 |
| PAGE_BTR_SEG_LEAF | 10 字节      | B+树叶子段的头部信息，仅在 B+树的 Root 页定义                                   |
| PAGE_BTR_SEG_TOP  | 10 字节      | B+树非叶子段的头部信息，仅在 B+树的 Root 页定义                                 |

#### 16. File Header（文件头部）

File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的 38 个字节，是由下边这些内容组成的：

| 名称                             | 占用空间大小 | 描述                                                                |
| -------------------------------- | ------------ | ------------------------------------------------------------------- |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 字节       | 页的校验和（checksum 值）                                           |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号，InnoDB 通过页号来可以唯一定位一个页                           |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                                      |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                                      |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2 字节       | 该页的类型                                                          |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值   |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                                    |

- FIL_PAGE_TYPE

这个代表当前页的类型，我们前边说过，InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：

| 类型名称                | 十六进制                       | 描述 |
| ----------------------- | ------------------------------ | ---- |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000 最新分配，还没使用      |
| FIL_PAGE_UNDO_LOG       | 0x0002 Undo 日志页             |
| FIL_PAGE_INODE          | 0x0003 段信息节点              |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004 Insert Buffer 空闲列表  |
| FIL_PAGE_IBUF_BITMAP    | 0x0005 Insert Buffer 位图      |
| FIL_PAGE_TYPE_SYS       | 0x0006 系统页                  |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007 事务系统数据            |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008 表空间头部信息          |
| FIL_PAGE_TYPE_XDES      | 0x0009 扩展描述页              |
| FIL_PAGE_TYPE_BLOB      | 0x000A 溢出页                  |
| FIL_PAGE_INDEX 0x45BF   | 索引页，也就是我们所说的数据页 |

- FIL_PAGE_PREV 和 FIL_PAGE_NEXT

需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的数据页（也就是类型为 FIL_PAGE_INDEX 的页）是有这两个属性的，所以所有的数据页其实是一个双链表

新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。

#### 17. File Trailer

我们知道 InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计 InnoDB 的大叔们在每个页的尾部都加了一个 File Trailer 部分，这个部分由 8 个字节组成，可以分成 2 个小部分：

（1）前 4 个字节代表页的校验和

这个部分是和 File Header 中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trailer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

（2）后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）

这个部分也是为了校验页的完整性的

这个 File Trailer 与 File Header 类似，都是所有类型的页通用的。

#### 18. 目录项记录

设计 InnoDB 的大叔们需要一种可以灵活管理所有目录项的方式。他们灵光乍现，忽然发现这些目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。

那 InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下：

0：普通的用户记录
1：目录项记录
2：最小记录
3：最大记录

目录项记录和普通的用户记录的不同点：

（1）目录项记录的 record_type 值是 1，而普通用户记录的 record_type 值是 0。

（2）目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。

（3）还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1，其他别的记录的 min_rec_mask 值都是 0。

除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是 0x45BF，这个属性在 File Header 中），页的组成结构也是一样一样的（就是我们前边介绍过的 7 个部分），都会为主键值生成 Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

#### 19. 聚簇索引

使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

（1）页内的记录是按照主键的大小顺序排成一个单向链表。

（2）各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

（3）存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

B+树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的 B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。

这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会自动的为我们创建聚簇索引。

另外有趣的一点是，在 InnoDB 存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

#### 20. InnoDB 的 B+树索引的注意事项

（1）根页面万年不动窝。

一个 B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

（2）内节点中目录项记录的唯一性。

为了让新插入记录能找到自己在那个页里，我们需要保证在 B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+树每一层节点中各条目录项记录除页号这个字段外是唯一的。

（3）一个页面最少存储 2 条记录
