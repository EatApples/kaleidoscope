### MySQL 是怎样运行的：从根儿上理解 MySQL

```
来源：掘金小册《MySQL 是怎样运行的：从根儿上理解 MySQL》
作者：小孩子4919，公众号「我们都是小青蛙」作者
```

#### 1. 客户端连接

```
mysql -h127.0.0.1 -uroot -P3307 -p
```

**小贴士**： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从 MySQL 5.7.20 开始，不推荐使用查询缓存，并在 MySQL 8.0 中删除。

#### 2. MySQL 存储引擎

MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能，MySQL 提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。

| 存储引擎  | 描述                                 |
| --------- | ------------------------------------ |
| ARCHIVE   | 用于数据存档（行被插入后不能再修改） |
| BLACKHOLE | 丢弃写操作，读操作会返回空内容       |
| CSV       | 在存储数据时，以逗号分隔各个数据项   |
| FEDERATED | 用来访问远程表                       |
| InnoDB    | 具备外键支持功能的事务存储引擎       |
| MEMORY    | 置于内存的表                         |
| MERGE     | 用来管理多个 MyISAM 表构成的表集合   |
| MyISAM    | 主要的非事务处理存储引擎             |
| NDB       | MySQL 集群专用存储引擎               |

```
// 查看当前服务器程序支持的存储引擎
SHOW ENGINES;

// 创建表时指定存储引擎
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;

// 修改表的存储引擎
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

#### 3. 存储引擎的各种功能

| Feature                               | MyISAM | Memory  | InnoDB | Archive | NDB   |
| ------------------------------------- | ------ | ------- | ------ | ------- | ----- |
| B-tree indexes                        | yes    | yes     | yes    | no      | no    |
| Backup/point-in-time recovery         | yes    | yes     | yes    | yes     | yes   |
| Cluster database support              | no     | no      | no     | no      | yes   |
| Clustered indexes                     | no     | no      | yes    | no      | no    |
| Compressed data                       | yes    | no      | yes    | yes     | no    |
| **Data caches**                       | no     | N/A     | yes    | no      | yes   |
| Encrypted data                        | yes    | yes     | yes    | yes     | yes   |
| **Foreign key support**               | no     | no      | yes    | no      | yes   |
| Full-text search indexes              | yes    | no      | yes    | no      | no    |
| Geospatial data type support          | yes    | no      | yes    | yes     | yes   |
| Geospatial indexing support           | yes    | no      | yes    | no      | no    |
| **Hash indexes**                      | no     | yes     | no     | no      | yes   |
| Index caches                          | yes    | N/A     | yes    | no      | yes   |
| **Locking granularity**               | Table  | Table   | Row    | Row     | Row   |
| **MVCC**                              | no     | no      | yes    | no      | no    |
| Query cache support                   | yes    | yes     | yes    | yes     | yes   |
| Replication support                   | yes    | Limited | yes    | yes     | yes   |
| Storage limits                        | 256TB  | RAM     | 64TB   | None    | 384EB |
| T-tree indexes                        | no     | no      | no     | no      | yes   |
| **Transactions**                      | no     | no      | yes    | no      | yes   |
| Update statistics for data dictionary | yes    | yes     | yes    | yes     | yes   |

MyISAM（主要的非事务处理存储引擎）：支持全文索引；支持 GEO；表锁；

Memory（置于内存的表）：支持哈希索引；分片受限；表锁；

INNODB（具备外键支持功能的事务存储引擎）：唯一支持聚簇索引；支持数据缓存；支持外键；支持全文索引；支持 GEO；行锁；唯一支持 MVCC；支持事务；

Archive（用于数据存档（行被插入后不能再修改））：行锁；

NDB（MySQL 集群专用存储引擎）：唯一支持集群数据库；支持数据缓存；支持外键；支持哈希索引；唯一支持 T-树索引；支持事务；

MyISAM，Memory，INNODB 的相同点：都有 B-树索引；都有恢复点；都有数据加密；都支持查询缓存；

#### 4. 配置文件的优先级

MySQL 将按照给定的顺序依次读取各个配置文件，如果该文件不存在则忽略。

值得注意的是，如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准。

如果在同一个配置文件中，在这些组里出现了同样的配置项，那么，将以最后一个出现的组中的启动选项为准。

如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启动选项为准！

配置是覆盖型的。

#### 5. 系统变量

系统变量比较牛逼的一点就是，对于大部分系统变量来说，它们的值可以在服务器程序运行过程中进行动态修改而无需停止并重启服务器。不过系统变量有作用范围之分，具体来说作用范围分为这两种：

GLOBAL：全局变量，影响服务器的整体操作。

SESSION：会话变量，影响某个客户端连接的操作。（注：SESSION 有个别名叫 LOCAL）

通过启动选项设置的系统变量的作用范围都是 GLOBAL 的，也就是对所有客户端都有效的。

在服务器程序运行期间通过客户端程序设置系统变量的语法：

```
SET [GLOBAL|SESSION] 系统变量名 = 值;
```

或者写成这样也行：

```
SET [@@(GLOBAL|SESSION).]var_name = XXX;
```

如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是 SESSION。也就是说 SET 系统变量名 = 值和 SET SESSION 系统变量名 = 值是等价的。

#### 6. 查看系统变量

我们可以使用下列命令查看 MySQL 服务器程序支持的系统变量以及它们的当前值：

```
SHOW VARIABLES [LIKE 匹配的模式];
```

由于系统变量实在太多了，如果我们直接使用 SHOW BLES 查看的话就直接刷屏了，所以通常都会带一个 LIKE 过滤条件来查看我们需要的系统变量的值。

既然系统变量有作用范围之分，那我们的 SHOW VARIABLES 语句查看的是什么作用范围的系统变量呢？

答：默认查看的是 SESSION 作用范围的系统变量。

当然我们也可以在查看系统变量的语句上加上要查看哪个作用范围的系统变量，就像这样：

```
SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式];
```

#### 7. 状态变量

为了让我们更好的了解服务器程序的运行情况，MySQL 服务器程序中维护了好多关于程序运行状态的变量，它们被称为状态变量。比方说 Threads_connected 表示当前有多少客户端与服务器建立了连接。

由于状态变量是用来显示服务器程序运行状况的，所以它们的值只能由服务器程序自己来设置，我们程序员是不能设置的。

与系统变量类似，状态变量也有 GLOBAL 和 SESSION 两个作用范围的，所以查看状态变量的语句可以这么写：

```
SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];
```

#### 8. 一些重要的字符集

字符集指的是某个字符范围的编码规则。

比较规则是针对某个字符集中的字符比较大小的一种规则。

在 MySQL 中，一个字符集可以有若干种比较规则，其中有一个默认的比较规则，一个比较规则必须对应一个字符集。

查看 MySQL 中查看支持的字符集和比较规则的语句如下：

```
SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
SHOW COLLATION [LIKE 匹配的模式];
```

MySQL 有四个级别的字符集和比较规则:服务器级别，数据库级别，表级别，列级别

| 字符集     | 字符个数             | 字节数 | 备注                       |
| ---------- | -------------------- | ------ | -------------------------- |
| ASCII      | 128                  | 1      |                            |
| ISO 8859-1 | 256                  | 1      | 别名 latin1，兼容 ASCII    |
| GB2312     | 7445=6763+682        | 1 或 2 | 兼容 ASCII 时，使用 1 字节 |
| GBK        | GB2312 扩充          | 1 或 2 | 兼容 GB2312                |
| utf8       | 所有字符             | 1 ～ 4 | 变长编码                   |
| utf16      | 所有字符             | 2 或 4 | 变长编码                   |
| utf32      | 所有字符             | 4      |                            |
| utf8mb3    | 阉割过的 utf8 字符集 | 1 ～ 3 | MySQL 中字符集             |
| utf8mb4    | 正宗的 utf8 字符集   | 1 ～ 4 | MySQL 中字符集             |

有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使用 1~3 个字节来表示一个字符，如果大家有使用 4 字节编码一个字符的情况，比如存储一些 emoji 表情啥的，那请使用 utf8mb4。

#### 9. MySQL 中字符集的转换

从发送请求到接收结果过程中发生的字符集转换：

（1）客户端使用操作系统的字符集编码请求字符串，向服务器发送的是经过编码的一个字节串。

（2）服务器将客户端发送来的字节串采用 character_set_client 代表的字符集进行解码，将解码后的字符串再按照 character_set_connection 代表的字符集进行编码。

（3）如果 character_set_connection 代表的字符集和具体操作的列使用的字符集一致，则直接进行相应操作，否则的话需要将请求中的字符串从 character_set_connection 代表的字符集转换为具体操作的列使用的字符集之后再进行操作。

（4）将从某个列获取到的字节串从该列使用的字符集转换为 character_set_results 代表的字符集后发送到客户端。

（5）客户端使用操作系统的字符集解析收到的结果集字节串。

character_set_client，服务器解码请求时使用的字符集。服务器认为客户端发送过来的请求是用 character_set_client 编码的。假设你的客户端采用的字符集和 character_set_client 不一样的话，这就会出现意想不到的情况。

character_set_connection，服务器处理请求时会把请求字符串从 character_set_client 转为 character_set_connection。character_set_connection 只是服务器在将请求的字节串从 character_set_client 转换为 character_set_connection 时使用，它是什么其实没多重要，但是一定要注意，该字符集包含的字符范围一定涵盖请求中的字符，要不然会导致有的字符无法使用 character_set_connection 代表的字符集进行编码。

character_set_results，服务器向客户端返回数据时使用的字符集。服务器将把得到的结果集使用 character_set_results 编码后发送给客户端。假设你的客户端采用的字符集和 character_set_results 不一样的话，这就可能会出现客户端无法解码结果集的情况。

我们通常都把 character_set_client 、character_set_connection、character_set_results 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换。为了方便我们设置，MySQL 提供了一条非常简便的语句：

```
SET NAMES 字符集名;
```

这一条语句产生的效果和我们执行这 3 条的效果是一样的：

```
SET character_set_client = 字符集名;
SET character_set_connection = 字符集名;
SET character_set_results = 字符集名;
```

#### 10. InnoDB 页

当我们想从表中获取某些记录时，InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？

不，那样会慢死，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。

页是 MySQL 中磁盘和内存交互的基本单位，也是 MySQL 是管理存储空间的基本单位。

InnoDB 数据页的 7 个组成部分，知道了各个数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

#### 11. InnoDB 行格式

我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。

InnoDB 存储引擎有 4 种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。

行溢出：一个页一般是 16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。

那发生行溢出的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生行溢出？
MySQL 中规定一个页中至少存放两行记录。你不用关注这个临界点是什么，只要知道如果我们一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列。

（1）COMPACT 行格式：一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。
（1-1）记录的额外信息：这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为 3 类，分别是变长字段长度列表、NULL 值列表和记录头信息。
（1-1-1）变长字段长度列表：在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！变长字段长度列表中只存储值为 非 NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的。
（1-1-2）NULL 值列表：如果表中没有允许存储 NULL 的列，则 NULL 值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：二进制位的值为 1 时，代表该列的值为 NULL。二进制位的值为 0 时，代表该列的值不为 NULL。
（1-1-3）记录头信息：除了变长字段长度列表、NULL 值列表之外，还有一个用于描述记录的记录头信息，它是由固定的 5 个字节组成。5 个字节也就是 40 个二进制位，不同的位代表不同的意思。
（1-2）记录的真实数据：记录的真实数据除了我们自己定义的列的数据以外，MySQL 会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：

| 列名        | 是否必须 | 占用空间 | 描述                    |
| ----------- | -------- | -------- | ----------------------- |
| DB_ROW_ID   | 否       | 6 字节   | 行 ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6 字节   | 事务 ID                 |
| DB_ROLL_PTR | 是       | 7 字节   | 回滚指针                |

**InnoDB 表对主键的生成策略**

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为 row_id 的隐藏列作为主键。

注意：对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

（2）Redundant 行格式：其实知道了 Compact 行格式之后，其他的行格式就是依葫芦画瓢了。我们现在要介绍的 Redundant 行格式是 MySQL5.0 之前用的一种行格式，也就是说它已经非常老了。下边我们从各个方面看一下 Redundant 行格式有什么不同的地方：
（2.1）字段长度偏移列表。没有了变长两个字，意味着 Redundant 行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。多了个偏移两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数值的差值来计算各个列值的长度。因为 Redundant 行格式并没有 NULL 值列表，所以在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为 NULL 的依据，该比特位也可以被称之为 NULL 比特位。
（2.2）记录头信息。Redundant 行格式的记录头信息占用 6 字节，48 个二进制位。

对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出 768 字节的那些页面也被称为溢出页。

（3&4）Dynamic 和 Compressed 行格式。这两种行格式类似于 COMPACT 行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字符串的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。另外，Compressed 行格式会采用压缩算法对页面进行压缩。

指定行格式的语法

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

在 mysql 中查询表的详细信息如下

```
use 库名
show table status like '表名';
```

MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

#### 12. 数据页结构

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能。

一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。

| 名称               | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------ | ------------------ | ------------ | ------------------------ |
| File Header        | 文件头部           | 38 字节      | 页的一些通用信息         |
| Page Header        | 页面头部           | 56 字节      | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26 字节      | 两个虚拟的行记录         |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8 字节       | 校验页是否完整           |

#### 13. 记录头信息

为了更好的管理在 User Records 中的这些记录，InnoDB 可费了一番力气呢，在哪费力气了呢？不就是把记录按照指定的行格式一条一条摆在 User Records 部分么？其实这话还得从记录行格式的记录头信息中说起。

| 名称         | 大小（单位：bit） | 描述                                                                                        |
| ------------ | ----------------- | ------------------------------------------------------------------------------------------- |
| 预留位 1     | 1                 | 没有使用                                                                                    |
| 预留位 2     | 1                 | 没有使用                                                                                    |
| delete_mask  | 1                 | 标记该记录是否被删除                                                                        |
| min_rec_mask | 1                 | B+树的每层非叶子节点中的最小记录都会添加该标记                                              |
| n_owned      | 4                 | 表示当前记录拥有的记录数                                                                    |
| heap_no      | 13                | 表示当前记录在记录堆的位置信息                                                              |
| record_type  | 3                 | 表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶节点记录，2 表示最小记录，3 表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                                                    |

- delete_mask

这个属性标记着当前记录是否被删除，占用 1 个二进制位，值为 0 的时候代表记录并没有被删除，为 1 的时候代表记录被删除掉了。

这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

- record_type

这个属性表示当前记录的类型，一共有 4 种类型的记录，0 表示普通记录，1 表示 B+树非叶节点记录，2 表示最小记录，3 表示最大记录。我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。

- next_record

这玩意儿非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据。

如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。

但是需要注意注意再注意的一点是，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum 记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum 记录（也就是最大记录） 。

不论我们怎么对页中的记录做增删改操作，InnoDB 始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

**小贴士**： 你会不会觉得 next_record 这个指针有点儿怪，为啥要指向记录头信息和真实数据之间的位置呢？为啥不干脆指向整条记录的开头位置，也就是记录的额外信息开头的位置呢？

因为这个位置刚刚好，向左读取就是记录头信息，向右读取就是真实数据。我们前边还说过变长字段长度列表、NULL 值列表中的信息都是逆序存放，这样可以使记录中位置靠前的字段和它们对应的字段长度信息在内存中的距离更近，可能会提高高速缓存的命中率。

**小贴士**： 当数据页中存在多条被删除掉的记录时，这些记录的 next_record 属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。

#### 14. Page Directory（页目录）

我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。设计 InnoDB 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：

（1）将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

（2）每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

（3）将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的 Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。

对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。所以分组是按照下边的步骤进行的：

（1）初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。

（2）之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的 n_owned 值加 1，表示本组内又添加了一条记录，直到该组中的记录数等于 8 个。

（3）在一个组中的记录数等于 8 个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中 4 条记录，另一个 5 条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。

通过记录的 next_record 属性遍历该槽所在的组中的各个记录。

#### 15. Page Header（页面头部）

设计 InnoDB 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分，它是页结构的第二部分，这个部分占用固定的 56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下表：

| 名称              | 占用空间大小 | 描述                                                                            |
| ----------------- | ------------ | ------------------------------------------------------------------------------- |
| PAGE_N_DIR_SLOTS  | 2 字节       | 在页目录中的槽数量                                                              |
| PAGE_HEAP_TOP     | 2 字节       | 还未使用的空间最小地址，也就是说从该地址之后就是 Free Space                     |
| PAGE_N_HEAP       | 2 字节       | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）                    |
| PAGE_FREE         | 2 字节       | 第一个已经标记为删除的记录地址，其他删除的通过 next_record 形成单链表，可被重用 |
| PAGE_GARBAGE      | 2 字节       | 已删除记录占用的字节数                                                          |
| PAGE_LAST_INSERT  | 2 字节       | 最后插入记录的位置                                                              |
| PAGE_DIRECTION    | 2 字节       | 记录插入的方向                                                                  |
| PAGE_N_DIRECTION  | 2 字节       | 一个方向连续插入的记录数量                                                      |
| PAGE_N_RECS       | 2 字节       | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）                  |
| PAGE_MAX_TRX_ID   | 8 字节       | 修改当前页的最大事务 ID，该值仅在二级索引中定义                                 |
| PAGE_LEVEL        | 2 字节       | 当前页在 B+树中所处的层级                                                       |
| PAGE_INDEX_ID     | 8 字节       | 索引 ID，表示当前页属于哪个索引                                                 |
| PAGE_BTR_SEG_LEAF | 10 字节      | B+树叶子段的头部信息，仅在 B+树的 Root 页定义                                   |
| PAGE_BTR_SEG_TOP  | 10 字节      | B+树非叶子段的头部信息，仅在 B+树的 Root 页定义                                 |

#### 16. File Header（文件头部）

File Header 针对各种类型的页都通用，也就是说不同类型的页都会以 File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦吧啦吧啦～ 这个部分占用固定的 38 个字节，是由下边这些内容组成的：

| 名称                             | 占用空间大小 | 描述                                                                |
| -------------------------------- | ------------ | ------------------------------------------------------------------- |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4 字节       | 页的校验和（checksum 值）                                           |
| FIL_PAGE_OFFSET                  | 4 字节       | 页号，InnoDB 通过页号来可以唯一定位一个页                           |
| FIL_PAGE_PREV                    | 4 字节       | 上一个页的页号                                                      |
| FIL_PAGE_NEXT                    | 4 字节       | 下一个页的页号                                                      |
| FIL_PAGE_LSN                     | 8 字节       | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| FIL_PAGE_TYPE                    | 2 字节       | 该页的类型                                                          |
| FIL_PAGE_FILE_FLUSH_LSN          | 8 字节       | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值   |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4 字节       | 页属于哪个表空间                                                    |

- FIL_PAGE_TYPE

这个代表当前页的类型，我们前边说过，InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的其实都是存储记录的数据页，其实还有很多别的类型的页，具体如下表：

| 类型名称                | 十六进制                       | 描述 |
| ----------------------- | ------------------------------ | ---- |
| FIL_PAGE_TYPE_ALLOCATED | 0x0000 最新分配，还没使用      |
| FIL_PAGE_UNDO_LOG       | 0x0002 Undo 日志页             |
| FIL_PAGE_INODE          | 0x0003 段信息节点              |
| FIL_PAGE_IBUF_FREE_LIST | 0x0004 Insert Buffer 空闲列表  |
| FIL_PAGE_IBUF_BITMAP    | 0x0005 Insert Buffer 位图      |
| FIL_PAGE_TYPE_SYS       | 0x0006 系统页                  |
| FIL_PAGE_TYPE_TRX_SYS   | 0x0007 事务系统数据            |
| FIL_PAGE_TYPE_FSP_HDR   | 0x0008 表空间头部信息          |
| FIL_PAGE_TYPE_XDES      | 0x0009 扩展描述页              |
| FIL_PAGE_TYPE_BLOB      | 0x000A 溢出页                  |
| FIL_PAGE_INDEX 0x45BF   | 索引页，也就是我们所说的数据页 |

- FIL_PAGE_PREV 和 FIL_PAGE_NEXT

需要注意的是，并不是所有类型的页都有上一个和下一个页的属性，不过我们本集中唠叨的数据页（也就是类型为 FIL_PAGE_INDEX 的页）是有这两个属性的，所以所有的数据页其实是一个双链表

新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。

#### 17. File Trailer

我们知道 InnoDB 存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），设计 InnoDB 的大叔们在每个页的尾部都加了一个 File Trailer 部分，这个部分由 8 个字节组成，可以分成 2 个小部分：

（1）前 4 个字节代表页的校验和

这个部分是和 File Header 中的校验和相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为 File Header 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在 File Header 中的校验和就代表着已经修改过的页，而在 File Trailer 中的校验和代表着原先的页，二者不同则意味着同步中间出了错。

（2）后 4 个字节代表页面被最后修改时对应的日志序列位置（LSN）

这个部分也是为了校验页的完整性的

这个 File Trailer 与 File Header 类似，都是所有类型的页通用的。

#### 18. 目录项记录

设计 InnoDB 的大叔们需要一种可以灵活管理所有目录项的方式。他们灵光乍现，忽然发现这些目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是主键和页号而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。

那 InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？别忘了记录头信息里的 record_type 属性，它的各个取值代表的意思如下：

0：普通的用户记录
1：目录项记录
2：最小记录
3：最大记录

目录项记录和普通的用户记录的不同点：

（1）目录项记录的 record_type 值是 1，而普通用户记录的 record_type 值是 0。

（2）目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。

（3）还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的 min_rec_mask 值为 1，其他别的记录的 min_rec_mask 值都是 0。

除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页（页面类型都是 0x45BF，这个属性在 File Header 中），页的组成结构也是一样一样的（就是我们前边介绍过的 7 个部分），都会为主键值生成 Page Directory（页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。

#### 19. 聚簇索引

使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

（1）页内的记录是按照主键的大小顺序排成一个单向链表。

（2）各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

（3）存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

B+树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

我们把具有这两种特性的 B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。

这种聚簇索引并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会自动的为我们创建聚簇索引。

另外有趣的一点是，在 InnoDB 存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

#### 20. InnoDB 的 B+树索引的注意事项

（1）根页面万年不动窝。

一个 B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

（2）内节点中目录项记录的唯一性。

为了让新插入记录能找到自己在那个页里，我们需要保证在 B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：

- 索引列的值
- 主键值
- 页号

也就是我们把主键值也添加到二级索引内节点中的目录项记录了，这样就能保证 B+树每一层节点中各条目录项记录除页号这个字段外是唯一的。

（3）一个页面最少存储 2 条记录

#### 21. MyISAM 中的索引方案

我们知道 InnoDB 中索引即数据，也就是聚簇索引的那棵 B+树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：

将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。

由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。

使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是**主键值 + 行号**的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！

这一点和 InnoDB 是完全不相同的，在 InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引！

如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和 InnoDB 中的索引差不多，不过在叶子节点处存储的是相应的列 + 行号。这些索引也全部都是二级索引。

#### 22. B+树索引的使用

B+树索引在空间和时间上都有代价，所以没事儿别瞎建索引。

B+树索引适用于下边这些情况：

- 全值匹配
- 匹配左边的列
- 匹配范围值
- 精确匹配某一列并范围匹配另外一列
- 用于排序
- 用于分组

在使用索引时需要注意下边这些事项：

- 只为用于搜索、排序或分组的列创建索引
- 为列的基数大的列创建索引
- 索引列的类型尽量小
- 可以只对字符串值的前缀建立索引
- 只有索引列在比较表达式中单独出现才可以适用索引
- 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。
- 定位并删除表中的重复和冗余索引
- 尽量使用覆盖索引进行查询，避免回表带来的性能损耗。

#### 23. MySQL 的数据目录

查看数据目录

```
SHOW VARIABLES LIKE 'datadir';
```

每个数据库都对应数据目录下的一个子目录，或者说对应一个文件夹，我们每当我们新建一个数据库时，MySQL 会帮我们做这两件事儿：

- 在数据目录下创建一个和数据库名同名的子目录（或者说是文件夹）。

- 在该与数据库名同名的子目录下创建一个名为 **db.opt** 的文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则是个啥。

（1）表在文件系统中的表示

InnoDB 和 MyISAM 这两种存储引擎都在数据目录下对应的数据库子目录下创建了一个专门用于描述表结构的文件，文件名是这样：**表名.frm**

（2）InnoDB 是如何存储表数据的

为了更好的管理这些页，设计 InnoDB 的大叔们提出了一个表空间或者文件空间（英文名：table space 或者 file space）的概念，这个表空间是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多很多很多个页，我们的表数据就存放在某个表空间下的某些页里。

- 系统表空间（system tablespace）

这个所谓的系统表空间可以对应文件系统上一个或多个实际的文件，默认情况下，InnoDB 会在数据目录下创建一个名为 **ibdata1**（在你的数据目录下找找看有木有）、大小为 12M 的文件，这个文件就是对应的系统表空间在文件系统上的表示。

- 独立表空间(file-per-table tablespace)

使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd 的扩展名而已，所以完整的文件名称长这样：**表名.ibd**

（3）MyISAM 是如何存储表数据的

在 MyISAM 中的索引全部都是二级索引，该存储引擎的数据和索引是分开存放的。所以在文件系统中也是使用不同的文件来存储数据文件和索引文件。而且和 InnoDB 不同的是，MyISAM 并没有什么所谓的表空间一说，表数据都存放到对应的数据库子目录下。
其中**表名.MYD**代表表的数据文件，也就是我们插入的用户记录；**表名.MYI**代表表的索引文件，我们为该表创建的索引都会放到这个文件中。

（4）视图在文件系统中的表示

我们知道 MySQL 中的视图其实是虚拟的表，也就是某个查询语句的一个别名而已，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个**视图名.frm** 的文件。

#### 24. 基于成本的优化

在一条单表查询语句真正执行之前，MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：

（1）根据搜索条件，找出所有可能使用的索引

（2）计算全表扫描的代价

（3）计算使用不同索引执行查询的代价

（4）对比各种执行方案的代价，找出成本最低的那一个

#### 25. MySQL 中事务的语法

如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合一致性的。

数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。

我们可以使用下边两种语句之一来开启一个事务：

```
mysql> BEGIN;
mysql> START TRANSACTION;
```

不过比 BEGIN 语句牛逼一点儿的是，可以在 START TRANSACTION 语句后边跟随几个修饰符，就是它们几个：

- READ ONLY：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。

- READ WRITE：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。

- WITH CONSISTENT SNAPSHOT：启动一致性读

如果我们不显式指定事务的访问模式，那么该事务的访问模式就是读写模式。

COMMIT 语句就代表提交一个事务。ROLLBACK 语句就代表中止并回滚一个事务。

这些会导致事务隐式提交的语句包括：

- 定义或修改数据库对象的数据定义语言（Data definition language，缩写为：DDL）。

- 隐式使用或修改 mysql 数据库中的表：当我们使用 ALTER USER、CREATE USER、DROP USER、GRANT、RENAME USER、REVOKE、SET PASSWORD 等语句时也会隐式的提交前边语句所属于的事务。

- 事务控制或关于锁定的语句：当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务

#### 26. redo 日志

我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。

与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的 redo 日志刷新到磁盘的好处如下：

（1）redo 日志占用的空间非常小

（2）redo 日志是顺序写入磁盘的

redo 日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。

自系统开始运行，就不断的在修改页面，也就意味着会不断的生成 redo 日志。redo 日志的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减了。InnoDB 的大叔为记录已经写入的 redo 日志量，设计了一个称之为 Log Sequence Number 的全局变量，翻译过来就是：日志序列号，简称 lsn。

#### 27. undo 日志

为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为回滚（英文名：rollback），这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。

是时候揭开 roll_pointer 的真实面纱了，这个占用 7 个字节的字段其实一点都不神秘，roll_pointer 本质就是一个指针，指向记录对应的 undo 日志。

删除的过程需要经历两个阶段：

阶段一：仅仅将记录的 delete_mask 标识位设置为 1，其他的不做修改（其实会修改记录的 trx_id、roll_pointer 这些隐藏列的值）。设计 InnoDB 的大叔把这个阶段称之为 delete mark

阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从正常记录链表中移除，并且加入到垃圾链表中，然后还要调整一些页面的其他信息。。设计 InnoDB 的大叔把这个阶段称之为 purge。

把阶段二执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。

在执行 UPDATE 语句时，InnoDB 对更新主键和不更新主键这两种情况有截然不同的处理方案。

（1）在不更新主键的情况下，又可以细分为被更新的列占用的存储空间不发生变化和发生变化的情况。

- 就地更新（in-place update）：更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行就地更新，也就是直接在原记录的基础上修改对应列的值。

- 先删除掉旧记录，再插入新记录：在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。我们这里所说的删除并不是 delete mark 操作，而是真正的删除掉，也就是把这条记录从正常记录链表中移除并加入到垃圾链表中，并且修改页面中相应的统计信息。

（2）更新主键的情况

将旧记录进行 delete mark 操作。这里是 delete mark 操作！也就是说在 UPDATE 语句所在的事务提交前，对旧记录只做一个 delete mark 操作，在事务提交后才由专门的线程做 purge 操作，把它加入到垃圾链表中。

根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。

#### 28. MVCC

我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，鱼和熊掌不可得兼，舍一部分隔离性而取性能者也。

脏写（Dirty Write）：如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写

脏读（Dirty Read）：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了脏读

不可重复读（Non-Repeatable Read）：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读

幻读（Phantom）：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读

**小贴士**： 那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。

SQL 标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

| 隔离级别         | 脏读         | 不可重复读   | 幻读         |
| ---------------- | ------------ | ------------ | ------------ |
| READ UNCOMMITTED | Possible     | Possible     | Possible     |
| READ COMMITTED   | Not Possible | Possible     | Possible     |
| REPEATABLE READ  | Not Possible | Not Possible | Possible     |
| SERIALIZABLE     | Not Possible | Not Possible | Not Possible |

脏写是怎么回事儿？怎么里边都没写呢？这是因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。

MySQL 在 REPEATABLE READ 隔离级别下，是可以禁止幻读问题的发生的。

对该记录每次更新后，都会将旧值放到一条 undo 日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。

核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，设计 InnoDB 的大叔提出了一个 ReadView 的概念。

在 MySQL 中，READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。

READ COMMITTED —— 每次读取数据前都生成一个 ReadView。

REPEATABLE READ —— 在第一次读取数据时生成一个 ReadView。

#### 29. 锁

怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选的解决方案：

方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁。

方案二：读、写操作都采用加锁的方式。

很明显，采用 MVCC 方式的话，读-写操作彼此并不冲突，性能更高，采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用 MVCC 来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行，那也是没有办法的事。

事务利用 MVCC 进行的读取操作称之为一致性读，或者一致性无锁读，有的地方也称之为快照读。所有普通的 SELECT 语句（plain SELECT）在 READ COMMITTED、REPEATABLE READ 隔离级别下都算是一致性读。

共享锁，英文名：Shared Locks，简称 S 锁。在事务要读取一条记录时，需要先获取该记录的 S 锁。

```
SELECT ... LOCK IN SHARE MODE;
```

独占锁，也常称排他锁，英文名：Exclusive Locks，简称 X 锁。在事务要改动一条记录时，需要先获取该记录的 X 锁。

```
SELECT ... FOR UPDATE;
```

（1）DELETE：对一条记录做 DELETE 操作的过程其实是先在 B+树中定位到这条记录的位置，然后获取一下这条记录的 X 锁，然后再执行 delete mark 操作。我们也可以把这个定位待删除记录在 B+树中位置的过程看成是一个获取 X 锁的锁定读。

（2）UPDATE：

在对一条记录做 UPDATE 操作时分为三种情况：

如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在 B+树中定位到这条记录的位置，然后再获取一下记录的 X 锁，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在 B+树中位置的过程看成是一个获取 X 锁的锁定读。

如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在 B+树中定位到这条记录的位置，然后获取一下记录的 X 锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在 B+树中位置的过程看成是一个获取 X 锁的锁定读，新插入的记录由 INSERT 操作提供的隐式锁进行保护。

如果修改了该记录的键值，则相当于在原记录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

（3）INSERT：一般情况下，新插入一条记录的操作并不加锁，设计 InnoDB 的大叔通过一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被别的事务访问

我们在对教学楼整体上锁（表锁）时，怎么知道教学楼中有没有教室已经被上锁（行锁）了呢？依次检查每一间教室门口有没有上锁？那这效率也太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计 InnoDB 的大叔们提出了一种称之为意向锁（英文名：Intention Locks）的东东：

- 意向共享锁，英文名：Intention Shared Lock，简称 IS 锁。当事务准备在某条记录上加 S 锁时，需要先在表级别加一个 IS 锁。

- 意向独占锁，英文名：Intention Exclusive Lock，简称 IX 锁。当事务准备在某条记录上加 X 锁时，需要先在表级别加一个 IX 锁。

IS、IX 锁是表级锁，它们的提出仅仅为了在之后加表级别的 S 锁和 X 锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实 IS 锁和 IX 锁是兼容的，IX 锁和 IX 锁是兼容的。

| 兼容性 | X      | IX     | S      | IS     |
| ------ | ------ | ------ | ------ | ------ |
| X      | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| IX     | 不兼容 | 兼容   | 不兼容 | 兼容   |
| S      | 不兼容 | 不兼容 | 兼容   | 兼容   |
| IS     | 不兼容 | 兼容   | 兼容   | 兼容   |

InnoDB 中的表级锁

（1）表级别的 S 锁、X 锁

（2）表级别的 IS 锁、IX 锁

（3）表级别的 AUTO-INC 锁：系统实现这种自动给 AUTO_INCREMENT 修饰的列递增赋值

**小贴士**： 需要注意一下的是，这个 AUTO-INC 锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之前介绍的锁在事务结束时释放是不一样的。

InnoDB 中的行级锁

（1）Record Locks：正经记录锁是有 S 锁和 X 锁之分的，让我们分别称之为 S 型正经记录锁和 X 型正经记录锁吧

（2）Gap Locks：这个 gap 锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享 gap 锁和独占 gap 锁这样的说法，但是它们起到的作用都是相同的。

我们说 MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上正经记录锁。不过这难不倒设计 InnoDB 的大叔，他们提出了一种称之为 Gap Locks 的锁，官方的类型名称为：LOCK_GAP，我们也可以简称为 gap 锁。

（3）Next-Key Locks：next-key 锁的本质就是一个正经记录锁和一个 gap 锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以设计 InnoDB 的大叔们就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为：LOCK_ORDINARY，我们也可以简称为 next-key 锁。

（4）Insert Intention Locks：插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁（插入意向锁就是这么鸡肋）

我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的 gap 锁（next-key 锁也包含 gap 锁，后边就不强调了），如果有的话，插入操作需要等待，直到拥有 gap 锁的那个事务提交。但是设计 InnoDB 的大叔规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。设计 InnoDB 的大叔就把这种类型的锁命名为 Insert Intention Locks，官方的类型名称为：LOCK_INSERT_INTENTION，我们也可以称为插入意向锁。

（5）隐式锁：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务 id 这个牛逼的东东的存在，相当于加了一个隐式锁
