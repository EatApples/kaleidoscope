### 依赖

所谓A依赖B，可以理解为A中某些功能的实现是需要调用B中的其他功能配合实现的。这里也可以拆分为两层含义：

A强依赖B。创建A的实例这件事情本身需要B来参加。

A弱依赖B。创建A的实例这件事情不需要B来参加，但是A实现功能是需要调用B的方法。

### 依赖注入
大部分人只是将IOC容器实现成一个“存储Bean的map”，将DI实现成“通过注解+反射将bean赋给类中的field”。

实际上很多人都忽视了DI的依赖调解的功能。而帮助我们进行依赖调解本身就是我们使用IOC+DI的一个重要原因。

在没有依赖注入的年代里，很多人都会将类之间的依赖通过构造函数传递（实际上是构成了强依赖）。当项目越来越庞大时，非常容易出现无法调解的循环依赖。

Spring的依赖注入模型：构造-注入-初始化

（1）类的构造，调用构造函数、解析强依赖（一般是无参构造），并创建类实例。

（2）类的配置，根据Field/GetterSetter中的依赖注入相关注解、解析弱依赖，并填充所有需要注入的类。

（3）类的初始化逻辑，调用生命周期中的初始化方法（例如@PostConstruct注解或InitializingBean的afterPropertiesSet方法），执行实际的初始化业务逻辑。

这样，构造函数的功能就由原来的三个弱化为了一个，只负责类的构造。并将类的配置交由DI，将类的初始化逻辑交给生命周期。

### 循环依赖

所谓循环依赖，其实也有两层含义：

强依赖之间的循环依赖（无法解决）。

弱依赖之间的循环依赖（可以解决）。

### 循环依赖的调解
Spring 的循环依赖调解，是将 原本是弱依赖关系的两者误当做是强依赖关系的做法 重新改回弱依赖关系的过程。

Spring 只有在单例情况下才会尝试解决循环依赖（Spring为了解决单例的循环依赖问题，使用了三级缓存），无法解决就只能抛出 BeanCurrentlyInCreationException 异常。

（1）构造器循环依赖：无法解决，只能抛出 BeanCurrentlyInCreationException 异常

（2）setter 循环依赖：Spring 容器提前暴露了刚好完成的构造器注入，但未完成其他步骤 (如 setter 注入 的 bean)。只能解决单例作用域的 bean 循环依赖

（3）prototype 范围的依赖处理：Spring 容器无法完成依赖注入，因为 Spring 容器不会缓存 prototype 作用域的 bean，因此无法提前暴露一个创建中的 bean。

### 非典型强依赖
配置类和普通的Bean有一个区别，就在于除了同样作为Bean被管理之外，配置类也可以在内部声明其他的Bean。

这样就存在一个问题，配置类中声明的其他Bean的构造过程其实是属于配置类的业务逻辑的一部分的。

也就是说我们只有先将配置类的依赖全部满足之后才可以创建他自己声明的其他的Bean（如果不加这个限制，那么在创建自己声明的其他Bean的时候，如果用到了自己的依赖，则有空指针的风险）。

除了构造注入会导致强依赖以外，一个Bean也会强依赖于暴露他的配置类。

不要对有@Configuration注解的配置类进行Field级的依赖注入。

Factory method injection should be used in "@Configuration" classes


### 资料来源
#### 1. 这个 Spring 循环依赖的坑，90% 的人都不知道！
https://blog.mythsman.com/post/5d838c7c2db8a452e9b7082c/

#### 2. Spring解密 - Bean 加载流程
https://blog.battcn.com/2018/01/17/spring/spring-4/
