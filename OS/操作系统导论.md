```
中文名：《操作系统导论》
英文名：《Operating Systems: Three Easy Pieces》
作者：Remzi H. Arpaci-Dusseau and Andrea C. Arpaci-Dusseau
英文版是免费开放的：http://pages.cs.wisc.edu/~remzi/OSTEP/
```

# 目录

不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之——荀子

### 1. 操作系统为什么将资源虚拟化？

答案显而易见：让系统更易于使用。

操作系统将物理资源（CPU，磁盘，内存等）转换为更通用、更强大且更易于使用的虚拟形式。我们有时将操作系统称为虚拟机。

为了让用户使用虚拟机的功能，操作系统会提供系统调用。

操作系统有时被称为资源管理器，因为虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问各自的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等）

### 2. 操作系统实际上做了什么？

操作系统

（1）取得 CPU、内存、磁盘等物理资源，并对它们进行虚拟化。

（2）处理与并发有关的麻烦且棘手的问题。

（3）持久地存储文件，从而使它们长期安全。

这就是本书所讲的三个模块。

### 3. 操作系统设计目标

（1）抽象：建立一些抽象，让系统方便和易于使用（不用考虑底层）

（2）高性能：提供高性能，最小化操作系统的开销

（3）隔离/保护：在应用程序之间，应用程序与操作系统之间提供保护（也就是所谓的隔离）

（4）可靠性：应用程序都强依赖操作系统，操作系统必须不间断地运行，操作系统力求提供高度的可靠性

（5）高效，安全，可移植

### 4. 什么是系统调用？

系统调用将控制转移（跳转）到操作系统中，同时提高硬件特权级别。

用户应用程序以所谓的用户模式运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能发起对磁盘的 IO 请求，不能访问任何物理内存页，或在网络上发送数据包。

在发起系统调用时（通常通过一个称为 trap 的特殊硬件指令），硬件将控制转移到预先指定的 trap 处理程序（即预先设置的操作系统），并同时将特权级别提升至内核模式。

在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 IO 请求或为程序提供更多内存等功能。当操作系统完成请求的服务时，它通过特殊的 trap 返回指令，将控制权交还给用户。该指令（return-from-trap）返回到用户模式，同时将控制权交还给应用程序，回到应用离开的地方。

# 第一部分：虚拟化

### 1. 进程

进程——操作系统提供的基本抽象。进程的非正式定义言简意赅：进程就是运行中的程序。

进程可以处于以下 3 种状态之一：

- 运行：在 CPU 上运行，执行指令
- 就绪：已准备好运行，但未分配 CPU 时间片
- 阻塞：等待发生其他事件才会准备运行（就绪）

### 2. 如何提供有许多 CPU 的假象？

操作系统通过虚拟化 CPU 来提供这种假象。

通过让一个进程只运行一个时间片，然后切换到其他进程，即所谓的时分共享 CPU 技术。潜在的开销就是性能损失，因为每个进程的运行就会慢一点。

### 3. 机制和策略

机制：一些低级方法或协议，实现了所需的功能。例如上下文切换，它让操作系统能够停止运行一个程序，并开始在给定的 CPU 上运行另外一个程序。

策略：在这些机制之上，策略是在操作系统内做出某种决定的算法。例如给定一组可能的程序要在 CPU 上运行，操作系统如何抉择？操作系统的调度策略会做这样的决定。

### 4. 机制：受限直接执行

在保持控制权的同时，获得高性能，是构建操作系统的主要挑战之一。

硬件通过提供不同的执行模式来协助操作系统：用户模式和内核模式。

要执行系统调用，程序必须执行特殊的陷阱（trap）指令。问题是，陷阱如何知道在 OS 内执行哪些代码？

内核通过在启动时设置陷阱表来实现。内核必须谨慎地控制在陷阱上执行的代码。

操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。

### 5. 进程切换时，操作系统如何重获 CPU 的控制权？

（1）协作方式：等待系统调用。大多数进程通过系统调用，将 CPU 的控制权转移给操作系统。如果应用程序执行了某些非法操作，也会将控制转移给操作系统。

（2）非协作方式：操作系统进行控制。需要硬件参与：时钟中断。启动时，操作系统必须启动时间，也必须通知硬件哪些代码在发生时钟中断时运行。

### 6. 上下文切换

操作系统为当前执行的进程保留一些寄存器的值（例如，保存到内核栈），并为即将执行的进程恢复一些寄存器的值（从内核栈读取）。

上下文切换的成本不仅仅来自寄存器的保存与恢复，程序运行时在 CPU 高速缓存，TLB，分支预测器和其他硬件中建立了大量的状态，切换时会导致状态的刷新，这可能导致显著的性能成本。

### 7. 进程调度

调度指标：周转时间=完成时间-到达时间。

调度策略：

（1）先进先出（FIFO）。可能带来护航效应，即一些耗时较少的潜在资源消费者，被排在重量级的资源消费者之后，导致周转时间变长。

（2）最短任务优先（SJF）。先运行最短的任务，然后是次短的任务，如此下去。也可能有护航问题。

（3）最短完成时间优先（STCF），或抢占式最短作业优先（PSJF）。几乎所有现代化的调度程序都是抢占式的。向 SJF 添加抢占，可以解决护航问题。

调度指标：响应时间=首次运行-到达时间。

调度策略：

（1）轮转（RR）。RR 在一个时间片内运行一个任务，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。RR 反复执行，直到所有任务都完成。系统设计者需要权衡时间片的长度，以便摊销上下文切换的成本，而又不会使系统不及时响应。

在周转时间与响应时间之间需要做权衡。第一种类型（SJF，STCF）优化周转时间，但对响应时间不利；第二种类型（RR）优化响应时间，但对周转时间不利。

### 8. 调度：多级反馈队列

多级反馈队列（MLFQ）需要解决 2 方面的问题：首先，优化周转时间；其次，降低响应时间。

多级反馈队列是用历史经验预测未来的典型例子，在操作系统中，使用此技术的有很多，比如硬件的分支预测及缓存算法。

多级反馈队列，它有多级队列，并利用反馈信息决定某个任务的优先级。以史为鉴：关注进程的一贯表现，然后区别对待。

MLFQ 的规则如下：

（1）先后规则：如果 A 的优先级> B 的优先级，运行 A（不运行 B）
（2）轮转规则：如果 A 的优先级=B 的优先级，轮转运行 A 和 B
（3）初始最高规则：任务进入系统时，放在最高优先级（最上层队列）
（4）用完下降规则：一旦任务用完其在某一层中的时间配额（不管中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）
（5）不断重置规则：经过一段时间 S，就将系统中所有任务重新加入最高优先级队列

S 的值如何设置？如果 S 设置得太高，长任务会饥饿；如果设置得太低，交互型任务又得不到合适的 CPU 时间比例。

MLFQ 不需要对任务的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，使得短时间的任务能获得类似 SJF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以稳步推进。

### 9. 调度：比例份额

比例份额调度程序，也称为公平份额调度程序，调度程序的最终目标，是确保每个任务获得一定比例的 CPU 时间，而不是优化周转时间与响应时间。

比例份额有一个非常优秀的现代例子：彩票调度。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。

彩票调度最精彩的地方在于利用了随机性。随机方法相对于传统的决策方式，至少有 3 点优势：

（1）避免奇怪的边界情况
（2）轻量，几乎不需记录任何状态
（3）很快

彩票调度中最不可思议的，或许就是实现简单。只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数。

比如有 3 个任务 ABC，彩票总数为 60，它们获得的彩票数分别为：A-10，B-20，C-30。现使用链表将 ABC 排列如下：A-B-C（C-B-A 等都可以），表示 A 的区间为[1，10]，B 的区间为[11，30]，C 的区间为[31，60]。然后获取一个在 1~60 的随机数，比如 34，则 C 被调度（因为刚好落在 C 的区间段）。

如何为任务分配彩票？这是一个棘手的问题，没有最佳答案。

虽然随机方式可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例。步长调度解决了这个问题，它是一个确定性的公平分配方案。

步长调度也很简单。系统中每个人物都有自己的步长，这个值与票数值成反比。每次进程运行后，让它的计数器增加它的步长，记录总体的进展。之后，调度程序使用进程的步长及行程值来确定调度哪个进程。当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后，将该进程的行程值增加一个步长。

比如以 60 为标准，前文 ABC 的步长分别为 A-6，B-3，C-2。因为刚开始调度时，ABC 的行程都是 0，随机选一个执行，比如 A，则 A 的行程为 6。之后 BC 中也随机选一个，比如选 B 执行，则 B 的行程为 3。之后肯定是 C 会执行，C 的行程为 2。此时，因为 C 的行程最短，则 C 会被再次执行。

在彩票调度中，票数值越高，理论上越容易被选中（基于大叔定律，概率趋于期望。但有例外，因为是随机性的）。而在步长调度中，票数值越高，步长越短，越容易被执行（小步快跑）。

彩票调度只能运行一段时间后，在概率上实现比例，而步长调度可以在每个调度周期后做到完全正确。既然如此，为什么还需要彩票调度？因为彩票调度有一个步长调度没有的优势：不需要全局状态。因此，彩票调度算法能够更合理地处理新加入的进程。

比例份额调度中，彩票调度通过随机值，聪明地做到了按比例分配。步长调度能够确定的获得需要的比例。但是，它们并没有作为 CPU 调度程序被广泛使用。一个原因是这两种方案都不能很好地适合 IO，另一个原因是其中最难的票数分配问题并没有确定的解决方案。

即使如此，在容易确定份额比例的场景（比如，在虚拟数据中心中，分配 1/4 的 CPU 周期给 Windows 系统，其他的给 Linux 系统），比例份额调度还能发挥优势：简单高效。

### 10. 多处理器调度

多处理器与单 CPU 的基本区别：区别的核心在于对硬件缓存的使用，以及多处理之间共享数据的方式。

（1）单队列多处理器调度（SQMS）。将所有需要调度的任务放在一个单独的队列中，然后按照 CPU 个数选择合适的任务来运行。

优势：简单，直接复用之前单 CPU 的调度方式。负载均衡好。

劣势：其一，缺乏可扩展性。多处理器环境下，需要加锁来保证正确性。而锁的使用非常耗时。其二，缺乏缓存亲和性。任务会在不同的处理器中执行，难以利用缓存的优势。

（2）多队列多处理器调度（MQMS）。基本调度框架包含多个调度队列，每个队列可以使用不同的调度策略。

优势：天生具有可扩展性。队列的数量会随着 CPU 的增加而增加，因此锁和缓存的争用都不是大问题。具有良好的缓存亲和度。

劣势：负载不均。如何解决？通过任务的跨 CPU 迁移，可以真正的实现负载均衡。系统如何发起这样的迁移？使用工作窃取（work stealing）技术。工作量较少的队列不定期地从其他较多的队列中“窃取”一个或多个工作，实现负载均衡。不定期到底是多长？找到合适的阈值仍然是黑魔法，这在系统策略设计中很常见。

（3）Linux 多处理器调度

在构建多处理器调度程序方面，Linux 社区一致没有达成共识。一直以来，存在 3 种不同的调度程序：

- O(1)调度程序，采用多队列，基于优先级的（类似 MLFQ），随着时间的推移改变进程的优先级，然后调度最高优先级进程，来实现调度目标。交互性得到了特别关注。
- 完全公平调度程序（CFS），采用多队列，基于确定的比例调度（类似步长调度）。
- BF 调度程序（BFS），采用单队列，基于比例调度，但采用更加复杂的方案，称为最早最合适虚拟截止时间优先算法（EEVEF）。

# 第二部分：并发

# 第三部分：持久性

# 本书定律一览

### 1. Lampson 定律

重要的是做对事。抽象和简化都不能替代做对事。

有时你必须做正确的事，当你这样做时，总是好过其他方案。

### 2. Ousterhout 定律

尽可能避免巫毒常量。即避免设置魔法值。

巫毒常量，举例来说，比如多级反馈队列中，设置的优先级重置的时间 S。
