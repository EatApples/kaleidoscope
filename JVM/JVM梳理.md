```
书籍：《深入理解Java虚拟机：JVM高级特性与最佳实践》
作者：周志明
```

# 读书笔记之 JVM 梳理

### 1. Java 至今流行的原因？

从 1995 年 Java 诞生开始，新的编程语言不断推陈出新，但是 Java 语言的热度一直名列前茅。这里从个人角度，尝试解释 Java 流行的原因。

（1）JVM

首先，肯定是各种硬件平台上的 Java 虚拟机。在硬件和源文件之间增加一个中间层 JVM，屏蔽了底层硬件的区别，达到了“一次编写，到处运行”的效果（横向-跨平台）。

Java 编译器分为前端编译器和后端编译器。前端编译器（javac）将源文件（java 文件）编译成 Java 字节码（class 文件），后端编译器（C1、C2 等）将字节码编译成机器码。这一步与具体的 JVM 的实现有关，不同的硬件平台有不同的机器指令，当然也需要有对应的 JVM。

字节码是连接源码和机器指令的桥梁，这样带来一个好处：其他非 java 语言只要能实现前端编译器，将源码编译成符合 JVM 规范的字节码，就能在 JVM 上运行。

JVM 是 Java 虚拟机规范，约束边界，但不指定具体实现，这就为多样性带来了可能。HotSpotVM 只是 JVM 的一种，但不是全部，用户可以有多种选择。

JVM 这种“前后端分离”的设计（指源码-前端编译器-字节码-后端编译器-机器码），解耦合，可扩展，正是 Java 流行的首要原因。

（2）面向对象

考察编程语言的发展，大概就是从面向过程向面向对象转变，最终走向面向函数。Java 立足于面向对象，逐步走向面向函数。

虽然编程语言表现形式不一，但是从机器指令（或汇编代码）来看，大家都是一堆堆二进制文件，用的都是冯·诺依曼结构，都不可能超越丘奇-图灵理论（可计算性理论）：没啥不同。

新的语言有后发优势，但肯定有一个被大众接受的过程。Java 语言的面向对象自然而然（所有类的父类都是 Object），入门门槛较低：没有对象的话，请先 new 一个。

（3）GC

就像人吃完饭后，不想洗碗一样，大多数程序员不想在编码过程中还要考虑对象的释放（以免内存泄漏）。

Java 有完善的内存回收机制，解放了程序员的生产力。

（4）兼容

穷则独善其身，达则兼济天下。编程世界中，硬件和软件总在发展。如果某一天你写的代码在新环境下不能用，而不得不重写一次，就像嚼完的甘蔗再嚼一遍一样，索然无味。

Java 保持兼容的能力（虽然某些逻辑已废弃，但仍然保留），这种“透明性”（指对程序员无感知）赋予了“一次编写，到处运行”新的含义（纵向-跨版本）。

（5）spring

这里其实说的是 Java 的开发框架，包括但不限于 JDK 自带的 API 类库（比如 JUC 并发包），SpringCloud，SpringBoot 等。还有各种流行的 Java 开源软件，比如 RocketMQ，Zookeeper 等。

这些好用的软件或最佳实践，降低了开发难度，减少了开发时间。Java 的生态丰富多样，这样才不至于“灭绝”。

总之，Java 的春天还远未结束。

### 2. OOM 会发生在哪些地方？

内存动态分配和垃圾回收技术是一种“围城”，欲戴王冠，必承其重。

Java 虚拟机运行时数据区，包括以下几个部分：

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

按照不同的维度，可以做不同的划分。

JVM 是基于栈的指令集架构，数据区简单可分为栈和堆。

栈包括：虚拟机栈，本地方法栈。

其中，只有虚拟机栈，本地方法栈和程序计数器是线程隔离的，其他部分（方法区，堆，本地库接口，执行引擎）由所有线程共享。

（1）程序计数器是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域（其实没有必要，就一个计数器，简单理解就是一个指针，指向将要执行的字节码的地址）

（2）虚拟机栈描述的是 java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度（递归调用方法时出现），将抛出栈溢出错误（StackOverflowError）。如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，则会抛出 OOM。

（3）本地方法栈与虚拟机栈一样，只不过调用的方法是 Native 方法（指非 java 方法），也会抛出栈溢出和 OOM。

（4）堆被所有线程共享，在虚拟机启动时创建。JVM 规范中说所有的对象实例以及数组都要在堆上分配（栈上分配、标量替换等优化技术带来了一些改变）。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出 OOM。

（5）方法区与堆一样，被线程共享（称之为非堆），存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。原则上，如何实现方法区属于虚拟机的实现细节，不受虚拟机规范约束（HotSpotVM 使用永久代来实现方法区）。当方法区无法满足内存分配需求时，将抛出 OOM（运行时常量池是方法区的一部分，例如 String#intern 方法可能造成 OOM）。

（6）直接内存（通常意义上的内存）不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也会被频繁的使用（NIO 会使用 Native 函数库直接分配堆外内存），在扩展时，由于受机器总内存的限制，可能出现 OOM。

### 3. new Object 时发生了什么？

（1）虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析与初始化。

（2）如果没有，将进行类加载过程。

（3）在类加载检查通过后，JVM 将为新生对象分配内存。

对象所需内存在类加载完后便可完全确定。为对象分配控件的任务等同于把一块确定大小的内存从 java 堆中划分出来。

内存分配方式有“指针碰撞”（堆中内存是规整的，只要移动指针即可）和“空闲列表”（堆中内存不规整）。

堆是否规整，由垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial，ParNew 等带 Compact 过程的收集器，系统采用指针碰撞；而使用 CMS 这种基于 Mark-Sweep 算法的收集器，采用空闲列表。

内存的分配也要考虑线程安全（因为堆对所有线程可见），解决方案有 2 种：一是分配时使用同步，例如使用 CAS。二是使用 TLAB（Thread Local Allocation Buffer），线程私有，无需同步。

（4）内存分配之后，JVM 需要将该内存初始化为零值（不包括对象头），保证对象的实例字段在 java 代码中可以不赋初值就能直接使用（就是给定默认值，例如 int 就是 0，引用类型就是 null）。

（5）JVM 进行后续的设置，例如将对象是哪个类的实例，对象的 GC 分代年龄等信息存放在对象头。

（6）此时一个对象已经诞生，但还未执行\<init\>方法。一般来说，执行 new 指令之后会接着执行\<init\>方法，把对象按照程序员的意愿进行初始化，这样，一个真正可用的对象才算完全产生出来。

### 4. 对象的内存布局？

对象在内存中存储的布局可分为 3 部分：对象头，实例数据和对齐填充。

（1）HotSpotVM 对象头包括 2 部分信息：MarkWord 和类型指针。

MarkWord 存储对象自身的运行时数据：哈希码，GC 分代年龄，锁状态标志，偏向线程 ID 等。MarkWord 大小为 1 个字（32 位虚拟机为 32bit，64 位虚拟机为 64bit），会根据对象的状态复用存储空间。

类型指针指向对象的类元数据，虚拟机根据这个指针来确定这个对象是哪个类的实例。如果对象是一个 java 数组，那对象头中还有一块用于记录数组长度的数据。

（2）实例数据是对象真正存储的有效信息，即各种类型的字段内容。无论从父类继承下来的，还是在子类（我理解为当前类）中定义的，都需要记录起来。

这部分的存储顺序会受到虚拟机分配策略参数和源码中定义顺序的影响。HotSpotVM 的默认策略是相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类（当前类）的之前。

（3）对齐填充不是必然存在，也没有特别的含义，仅仅起占位符的作用。HotSpotVM 要求对象的大小是 8 字节的整数倍（内存对齐）。

### 5. 对象的访问定位？

使用对象时，需要从栈上的 reference 数据来操作堆上的具体对象。JVM 规范只规定了一个指向对象的引用，对象的访问方式取决于 JVM 的实现。目前主流的访问方式有 2 种：使用句柄和直接指针。

使用句柄，堆中将会划分出一块内存作为句柄池。reference 中存的就是对象的句柄地址，而句柄包括 2 个指针：一个指向对象实例数据，一个指向对象类型数据。

HotSpotVM 采用的是直接指针，reference 直接指向对象的地址，在对象头中存储了类型指针。

使用句柄的最大好处就是 reference 存储的是稳定的句柄地址，在对象移动时，只会改变句柄中的实例数据指针，而 reference 本身不会修改。

直接指针的优势是访问速度更快，因为节省了一次指针定位的开销。

### 6. 如何内存回收？

GC 需要完成的 3 个事情：

- WHAT：哪些内存需要回收？
- WHEN：何时回收?
- HOW：如何回收？

（1）WHAT：死对象需要回收。

对象已死怎么判断？采用引用计数法或可达性分析算法（引用链）。

引用计数法不能解决循环依赖的问题，故不采用。

在 Java 中，可作为 GCRoot 的对象有以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；

在 java 中按照对 GC 的影响，将引用分为强软弱虚 4 种。

方法区（HotSpotVM 中的永久代）中的废弃常量和无用的类也可以回收。

无用的类，必须满足 3 个条件：

- 无实例：该类的所有实例都已经被回收，即堆中不存在该类的任何实例；
- 无加载器：加载该类的 classLoader 已经被回收；
- 无类反射：该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过类反射访问该类的方法

虚拟机可以对无用的类进行回收，但到底做不做，由虚拟机决定。

（2）WHEN：安全点时回收。

基于可达性分析的算法，需要确保引用在某个瞬间不再变化，看起来像冻结一样，即 STW（Stop The World）。

程序执行时，并非在所有地方都能停下来开始 GC，只有到达安全点时才能暂停。安全点是特定的位置，以“是否具有让程序长时间执行的特征”为标准选定，例如方法调用，循环跳转等。

GC 发生时，让所有线程跑到最近的安全点再停顿下来（也可进入安全区域：在安全区域中，引用关系不再发生变化）。

如何停顿？有 2 种方案 ：抢占式中断和主动式中断。

抢占式中断在 GC 发生时，首先把所有线程全部中断，然后让它们跑到安全点。

主动式中断不直接对线程进行操作，只是设置一个 GC 标志，让各个线程主动去轮询，为真时线程就主动挂起。

（3）HOW：分代收集算法。

根据对象的存活周期的不同，将内存划分为几块，一般分为新生代和老年代。根据各个年代的特点，采取适当的收集算法。

标记-清除算法：最为基础，分为标记与清除 2 个阶段。首先标记出需要回收的对象，然后统一回收被标记的对象。不足之处有 2 个：一是效率问题，标记和清除的效率不高（可以通过并发标记，多线程来提速）；二是空间问题，标记清楚后有内存碎片（可以通过整理来避免）

复制算法：将内存分为大小相等的 2 块，每次只使用其中一块。当内存回收时，将存活对象复制到另一块，释放当前块。实现简单，运行高效，但是空间利用率只有 50%（HotSpotVM 按照 1:1:8 划分为 3 块，使用率达到了 90%）

标记-整理算法：类似标记-清除算法，但后期不是直接清除，而是让所有存活对象都向一端移动，然后清理端边界以外的内存。

在新生代，对象朝生夕灭，选用复制算法。

老年代对象存活率高，必须使用“标记-清除”或“标记-整理”算法。

### 7. 垃圾收集器如何组合？

如果说收集算法（复制，标记-清除，标记整理等）是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

这里以 HotSpotVM 的实现为例，说下垃圾收集器在不同年代是如何配合使用的。

注意：没有万能的收集器，也没有最好的收集器，只有适合的收集器。

在新生代：Serial，ParNew，Parallel Scavenge

在老年代：Serial Old，Parallel Old，CMS

横跨新生代与老年代：G1

（1）Serial：单线程-复制

单线程的意义不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更多的是说明它会 STW，直到收集结束。

Serial 是虚拟机运行在 Client 模式（采用 C1 编译器）下的默认新生代收集器：简单而高效。

（2）ParNew：多线程-复制

ParNew 是 Serial 的多线程版本（多线程收集），运行在 Server 模式（采用 C2 编译器）下的首选新生代收集器。

除了 Serial 外，只有 ParNew 才能与 CMS 配合。

在多 CPU 的机器上，表现效果整体优于 Serial。

（3）Parallel Scavenge：多线程-吞吐量优先-复制

Parallel Scavenge 的目标是达到一个可控制的吞吐量，即吞吐量优先。

吞吐量=运行代码的时间 / (运行代码的时间 + 垃圾收集的时间)

与 ParNew 不同，Parallel Scavenge 还会自适应调节策略，动态调整参数以达到最合适的停顿时间或最大的吞吐量。

（4）Serial Old：单线程-标记-整理

Serial Old 是 Serial 的老年代版本，有 2 个作用：一是在 JDK15 之前配合 Parallel Scavenge 使用（JDK16 时出现了 Parallel Old）；二是作为 CMS 的后备预案。

（5）Parallel Old：多线程-吞吐量优先-标记-整理

Parallel Old 是 Parallel Scavenge 的老年代版本，直到这时，吞吐量优先的新老组合才名副其实。

（6）CMS：多线程-标记-清除

CMS 是以获取最短停顿时间为目标的收集器，分为：

- 初始标记（需 STW）
- 并发标记
- 重新标记（需 STW）
- 并发清除

4 个步骤。

CMS 远达不到完美，有以下 3 个明显的缺点：

- CPU 敏感，占 CPU
- 无法处理浮动垃圾，如果出现 Concurrent Mode Failure，需要 Serial Old 来救场
- 基于标记-清除，需要处理碎片问题

  （7）G1：标记-整理-考虑停顿时间，优先回收价值最大的 Region

  在 G1 之前，其他收集器进行收集的范围都是整个新生代和老年代。使用 G1 之后，java 堆的内存布局发生变化：它将整个堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但这两者之间不再物理隔离，它们都是一部分 Region（不需要连续） 的集合。

G1 的特点：

- 并行与并发：利用多 CPU 的优势，缩短 STW 的时间
- 分代收集：采用不同方式处理新建对象与旧对象
- 空间整合：整体上看是标记-整理，从 Region 上看是复制，总之不会产生内存碎片
- 可预测的停顿：能建立可预测的停顿模型，能指定在 M 毫秒时间片内，进行垃圾收集的时间小于 N 毫秒

G1 的收集步骤，大致与 CMS 类似：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

### 8. GC 日志如何理解？

注意 2 点:

（1）GC 日志开头的[GC][fullgc] 说明了垃圾回收的停顿类型，而不是用来区分新生代还是老年代！如果有 Full，说明发生了 STW

（2）GC 时间这块，user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，而 real 指的是从开始到结束的耗时，包括非运算等待耗时，例如等待磁盘 IO，等待线程阻塞等。一般情况下，real 会大于 user 与 sys。但如果多核，则 CPU 时间会叠加，可能导致 user 或 sys 会超过 real

### 9. 内存分配策略？

自动内存管理最终可总结为解决了 2 个问题：给对象分配内存，以及回收分配给对象的内存。

回收的策略已经提过，即分代收集：各种垃圾收集器的组合。

分配的规则并不固定，取决于垃圾回收器的组合，还有虚拟机与内存相关的参数设置。但还是有几条最普遍的内存分配规则：

- 对象优先在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代（何谓长期？指的是经过 15 次（默认值） GC 还存活，则可晋级）

### 10. 类文件结构小知识

- 整个 Class 文件（指 javac 前端编译后生成的 .class 文件）本质上就是一张表（由多个无符号数和其他表复合而成，举例来说，Class 的头 4 个字节是魔数，即 0xcafebabe，然后是次主版本号，常量池，接口，字段，方法，属性等），各个数据项目紧凑排列，是一组以 8 字节为基础单位的二进制流
- 常量池中主要存放 2 大类常量：字面量（字符串，final 修饰的常量等）和符号引用（类和接口的全限定名，字段的名称和描述符，方法的名称和描述符），常量池类似字典表，池中的项目相互引用
- java 程序中如果定义超过 64kb（2^16）英文字符的常量或方法名，则无法编译，因为最大长度就是 2 字节能表示的范围（2^16）
- 除了 java.lang.Object 外，所有 java 类的父类索引都不为 0（至少有一个共同祖先：Object）
- 方法中的代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面
- JVM 中指令的种类有上限，即 256 条，目前已经定义了 200 多条
- 虚拟机规范中明确限制了一个方法不允许超过 65535 条字节码指令
- 在任何实例方法里面，都可以通过“this”关键字访问到方法所属的对象（this 是默认的一个方法入参）
- 编译器使用异常表而不是简单的跳转命令来实现 java 异常及 finally 处理机制
- 对于非 static 类型的变量（实例变量）的赋值是在实例构造器\<init\>方法中进行，而类变量，有类构造器\<clinit\>方法和 ConstantValue 属性（javac 的选择是，当 final static 修饰基本类型和 String 时使用 ConstantValue 属性）
- 正确实现 synchronized 关键字需要 javac 编译器与 JVM 两者共同协作支持
- Class 文件格式所具备的平台中立（不依赖特定的硬件及操作系统）、紧凑、稳定和可扩展的特点，是 java 技术体系实现平台无关、语言无关两项特性的重要支柱

### 11. 类加载小知识

- java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接实现的（比如 OSGi，Open Service Gateway Initiative 技术）
- 数组类本身不通过类加载器创建，而是由 JVM 直接创建
- 一个类必须与类加载器一起确定唯一性
- Class 对象比较特殊，它虽然是对象，但是存放在方法区，这个对象将作为程序访问方法区中的这些类型数据的外部接口
- 如果在一个类的\<clinit\>方法中有耗时很长的操作，就可能造成多个线程阻塞（因为\<clinit\>方法是线程安全的，只会有一个线程执行，而且其他操作必须在该初始化方法之后才能进行）
- 双亲委派模型并不是一个强制性的约束模型，而是推荐的类加载器实现方式，历史上共有 3 次例外：一是双亲委派模型出来之前；二是 SPI 加载动作；三是 OSGi 技术
- 类变量有 2 次赋初始值的过程，一次在准备阶段，赋予系统初始值；另一次在初始化阶段，赋予程序员定义的初始值

### 12. 动态方法调用，使用方法句柄（MethodHandle）还是类反射（Reflection）？

（1）本质上，MethodHandle 与 Reflection 机制都是模拟方法调用，但 Reflection 是在模拟 java 代码层次的方法调用，而 MethodHandle 是在模拟字节码层次的方法调用；

（2）Reflection 是重量级（包含方法属性表中各种信息等），而 MethodHandle 是轻量级（仅包含与执行该方法相关的信息）；

（3）MethodHandle 是对字节码的方法指令调用的模拟，理论上可被优化（比如方法内联），而通过 Reflection 去调用方法则不行；

（4）Reflection API 的设计目标是只为 java 语言服务的，而 MethodHandle 则设计成可服务于所有 JVM 之上的语言，其中也包括 java 语言

### 13. 为什么 JVM 采用面向操作数栈而不是寄存器的架构？

JVM 相当于小型的操作系统，它有自己的指令集，基本上是一种基于栈的指令集架构。指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。

与之对应的就是基于寄存器的指令集，典型的就是 x86 的二地址指令集，简单来说就是 PC 机中直接支持的指令集架构，这些指令依赖寄存器进行工作。

两套指令集各有优势，基于栈的指令集的优势有：

- 可移植（寄存器由硬件提供，依赖寄存器就要受到硬件的约束，用户程序不直接操作，完全由虚拟机代管）
- 代码相对紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）
- 编译器实现简单（不需要考虑空间分配的问题，所需空间都在栈上操作）

栈架构指令集的主要缺点是执行速度相对来说慢一点（指令多，与内存而不是寄存器交互）。所有主流物理机的指令集都是寄存器架构也从侧面印证这一点（硬件世界，CPU 最快，寄存器次之，所以寄存器都在 CPU 周围；其次是高速缓存 cache，然后才是内存）。

### 14. java 中有哪些编译器？

（1）前端编译器（把 \*.java 转换为 \*.class 文件）: Sun 的 javac

（2）JIT 编译器（虚拟机的后端运行期编译器，把字节码转换为机器码）: HotSpotVM 的 C1、C2 编译器

（3）AOT 编译器（静态提前编译器，直接把 \*.java 编译成本地机器代码）：GNU Compiler for the Java

### 15. java 中对代码如何优化？

虚拟机设计团队把对性能的优化集中在后端的即时编译器中，这样可以让那些非 javac 产生的 Class 文件（比如 JRuby）也能同样获得编译器优化带来的好处。

javac 做了很多针对 java 语言编码过程中的优化措施，来改善程序员的编码风格和提高编码效率。相当多新生的 java 语法特性，都是靠编译器的“语法糖”来实现（例如：foreach，try-with-resources）

尽管并不是所有的 java 虚拟机都采用解释器与编译器并存的架构，但许多主流的商业虚拟机，如 HotSpotVM，都同时包含解释器与编译器。

当程序需要迅速启动和执行，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器开始发挥作用，将越来越多的代码编译成本地机器码，获得更高的执行效率。解释器可作为编译器的后备，当优化不成立时可以回退。

HotSpotVM 中采用分层编译，其中包括：

- 第 0 层，程序解释执行，解释器不开启性能监控功能，可触发第 1 层编译；
- 第 1 层，C1 编译，将字节码编译为本地代码，简单可靠的优化，如有必要将加入性能监控的逻辑；
- 第 2 层，C2 编译，也是将字节码编译为本地代码，但会启用编译耗时较长的优化，还会激进优化（会做很多乐观的假设）

哪些代码会被编译呢（即热点代码）？

- 被多次调用的方法
- 被多次执行的循环体

如何发现热点代码？

- 基于采样的热点探测
- 基于计数器的热点探测

HotSpotVM 采用第二种，具体有方法调用计数器和回边计数器（在字节码中遇到控制流向后跳转的指令称为回边。简单来说就是统计循环体执行的次数）

经典的优化动作有很多，例如：

- 无用代码消除
- 循环展开
- 循环表达式外提
- 常量传播
- 基本块重排序
- 分支预测

最具有代表性的优化技术：

（1）语言无关的经典优化技术之一：公共子表达式消除；

（2）语言相关的经典优化技术之一：数组范围检查消除；

（3）最重要的优化技术之一：方法内联；

（4）最前沿的优化技术之一：逃逸分析；

### 16. 多线程是如何实现的？

进程是资源分配的最小单位，而线程是 CPU 调度的最小单位。

线程的引入，把进程的资源和执行调度分开，各个线程可以共享进程资源，又可以独立调度。

主流的操作系统都提供了线程实现，java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理。每个已经执行 start 方法且还未结束的 Thread 类的实例就代表了一个线程。

实现线程主要有 3 种方式：

（1）使用内核线程实现（一对一的线程模型）

内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成切换。内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。

程序一般不会直接使用内核线程，而是去使用内核线程的高级接口——轻量级进程（LWP），即通常意义上所讲的线程（轻量级进程与内核线程是一对一的）。

一个系统支持轻量级进程的数量是有限的。

（2）使用用户线程实现（一对多的线程模型）

广义上，一个线程不是内核线程，就是用户线程。

狭义上，用户线程完全建立在用户空间的线程库上，系统内核不能感知线程存在。

由于没有内核的支援，是优势也是劣势，使用用户线程实现的程序一般都比较复杂，java 曾经使用过（绿色线程），最终早已放弃（JDK12）。

（3）使用用户线程加轻量级进程混合实现（多对多的线程模型）

Java 线程模型目前为基于操作系统原生线程模型实现。对于 sun JDK 来说，Windows 和 Linux 版本都是使用一对一的线程模型实现的，一条 java 线程就映射到一条轻量级进程之中，因为 Windows 和 Linux 系统提供的线程模型就是一对一的。

线程调度是指系统为线程分配处理器使用权的过程，主要有 2 种：

- 协同式线程调度（线程执行完后主动切换另外线程）
- 抢占式线程调度（由系统来分配执行时间）

java 使用的线程调度方式是抢占式调度，可通过设置线程优先级完成。不过，线程优先级不太靠谱，因为 java 线程依赖系统原生线程，所以线程调度最终还是取决于操作系统。

JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现。

### 17. 如何实现线程安全？

线程安全：当多个线程访问一个对象时（共享对象），如果不用考虑这些线程在运行时环境下的调度和交替执行（不假定执行次序），也不需要额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

按照线程安全的强弱程度，可将 java 中共享的数据分为以下 5 类：

（1）不可变对象一定是线程安全的（比如 String 对象，枚举类型）

（2）绝对线程安全（符合线程安全定义的。在 java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全）

（3）相对线程安全（在 java 语言中，大部分的线程安全类都是这种类型，例如 HashTable）

（4）线程兼容（对象不是线程安全，但通过额外的同步能在并发环境下安全的使用，比如使用锁来同步的 HashMap）

（5）线程对立（即使采取额外同步，也不能正确的并发执行）

对于线程兼容的对象如何实现线程安全？

- 互斥同步（例如：synchronized 关键字，锁）
- 非阻塞同步（例如：CAS 等原子指令，需要硬件支持，可认为是乐观同步）
- 可重入代码（例如：幂等函数，相同的输入不管执行几次，都是相同的输出）
- 线程本地存储（例如：ThreadLocal，都是线程内的私有数据，当然没有同步问题）

### 18. 垃圾收集器的组合

（1）UseSerialGC is "Serial" + "Serial Old"
（2）UseParNewGC is "ParNew" + "Serial Old"
（3）UseConcMarkSweepGC is "ParNew" + "CMS" + "Serial Old". "CMS" is used most of the time to collect the tenured generation. "Serial Old" is used when a concurrent mode failure occurs.
（4）UseParallelGC is "Parallel Scavenge" + "Serial Old"
（5）UseParallelOldGC is "Parallel Scavenge" + "Parallel Old"
（6）-XX:+UseG1GC
