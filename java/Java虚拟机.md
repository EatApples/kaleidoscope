### `Java`虚拟机
本文是学习《极客时间》`郑雨迪`主讲的 `《深入拆解Java虚拟机》` 的个人总结。

### 1. 基本原理
#### 1.1 操作码
`Java`字节码指令的操作码（`opcode`）被固定为一个字节。

#### 1.2 方法区
加载后的`Java`类会被存放于方法区（`Method Area`）。实际运行时，虚拟机会执行方法区内的代码。

#### 1.3 基本类型
`Java`基本类型（8种）：`boolean`，`byte`，`short`，`char`，`int`，`long`，`float`，`double`。其中`boolean`和`char`是无符号类型。

#### 1.4 正无穷和负无穷
在`Java`中，浮点数的正无穷和负无穷有确切数值，在内存中分别为十六进制`0x7F800000`（正无穷），`0xFF800000`（负无穷）。

#### 1.5 `NaN`
`NaN`（`Not-a-Number`）除了`!=`始终返回`true`外，所有其他比较结果都会返回`false`。

#### 1.6 引用类型
`Java`引用类型细分为4种：`类`，`接口`，`数组类`，`泛型参数`。泛型参数在编译过程中被擦除，数组类由`Java`虚拟机直接生成，类和接口有对应的字节流。

#### 1.7 加载
加载：在`Java`虚拟机中，类的唯一性由类加载器实例以及类的全名一同确定。加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在`Java`虚拟机中，类加载器使用双亲委派模型。

#### 1.8 链接
链接：分为`验证`（确保加载的类满足`Java`虚拟机的约束条件），`准备`（为被加载类的静态字段分配内存，构造与该类相关联的方法表）以及`解析`（解析阶段的目的，正是将`符号引用`解析成`实际引用`。如果符号引用指向未被加载的类，或未被加载类的字段或方法，那么解析将触发这个类的加载，但未必触发这个类的链接及初始化）三阶段。`Java`虚拟机规范并没有要求在链接过程中完成解析：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

#### 1.9 初始化
除此（满足直接赋值，被`final`修饰，类型为基本类型或字符串的静态字段，会被`Java`编译器标记为`常量值`，初始化由`Java`虚拟机完成）之外的直接赋值操作，以及所有静态代码块中的代码，会被`Java`编译器置于同一方法`clinit`中。初始化：为标记为`常量值`的字段赋值，以及执行`clinit`方法的过程。`Java`虚拟机会通过加锁来确保类的`clinit`方法仅被执行一次。类的初始化是线程安全的，并且仅被执行一次。只有初始化完成之后，类才正式成为可执行的状态。`JVM`规范枚举了以下多种触发情况：
+ （1）当虚拟机启动时，初始化用户指定的主类；
+ （2）当遇到`new`指令时，初始化`new`指令的目标类；
+ （3）当遇到调用静态方法的指令时，初始化该静态方法所在的类；
+ （4）当遇到访问静态字段的指令时，初始化该静态字段所在的类；
+ （5）子类的初始化会触发父类的初始化；
+ （6）如果一个接口定义了`default`方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化；
+ （7）使用反射`API`对某个类进行发射调用时，初始化这个类；
+ （8）初次调用 `MethodHandle` 实例化时，初始化该`MethodHandle`指向的方法所在的类。

#### 1.10 重载
重载的方法在编译过程中即可完成识别，因此可以认为`Java`虚拟机中不存在重载。`Java`编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。考虑是否允许基本类型自动装拆箱与可变长参数，这个过程分为有序的三个阶段，如果前面阶段没有适配，再考虑下一阶段：00（都不允许），10（允许装拆箱但不允许可变长），11（全都允许）。如果在同一阶段找到多个适配的方法，则会选择一个最为贴切的（关键就是形参类型的继承关系）。

#### 1.11 重写
方法重写：多态的重要的一种体现方式。它允许子类在继承父类部分功能的同时，拥有自己独特的行为。重写调用会根据调用者的动态类型，来选取实际的目标方法。

#### 1.12 识别方法
`Java`虚拟机识别方法的关键在于类名、方法名以及方法描述符（`method descriptor`）（由方法的参数类型以及返回类型所构成）。注意`Java`虚拟机与`Java`语言语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中。对于调用这些方法的字节码来说，由于字节码附带的方法描述符包含了返回类型，因此`Java`虚拟机能够准确地识别目标方法。

#### 1.13 方法重写判定
`Java`虚拟机关于方法重写的判定基于方法的描述符。如果子类定义了与父类中非私有、非静态同名方法的方法，那么只有当这两个方法的参数类型以及返回类型一致，`Java`虚拟机才会判定为重写。

#### 1.14 桥接方法
对于`Java`语言中重写而`Java`虚拟机中非重写的情况，编译器会通过生成桥接方法来实现`Java`中的重写定义。

#### 1.15 静态绑定与动态绑定
`Java`虚拟机中的静态绑定指的是在解析时能够直接识别目标方法的情况；而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

#### 1.16 符号引用
在编译过程中，我们并不知道目标方法的具体内存地址。`Java`编译器会暂时用符号引用来表示该目标方法（包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符）。

#### 1.17 静态方法
静态方法可以通过子类来调用。子类的静态方法会隐藏（不是重写）父类中的同名、同描述符的静态方法。

#### 1.18 实际引用
对于静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于动态绑定的方法调用而言，实际引用则是一个方法表的索引。

#### 1.19 调用指令
具体来说，`Java`字节码中与调用相关的指令共5种：
+ `invokestatic`：用于调用静态方法；
+ `invokespecial`： 用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法；
+ `invokevirtual`：用于调用非私有实例方法；
+ `invokeinterface`：用于调用接口方法；
+ `invokedynamic`：用于调用动态方法。

#### 1.20 虚方法调用
`invokevirtual`与`invokeinterface`这两种指令，均属于`Java`虚拟机中的虚方法调用。静态绑定包括`invokestatic`与`invokespecial`指令。如果虚方法调用指向一个标记为`final`的方法，那么`Java`虚拟机也可以静态绑定该虚方法调用。

#### 1.21 方法表
`Java`虚拟机采用空间换时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

#### 1.22 内联缓存
内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。`Java`虚拟机只采用单态（还有多态，超多态，按照缓存动态类型的个数划分）内联缓存。

#### 1.23 捕获异常
捕获异常涉及如下三种代码块：
+ `try`代码块：用来标记需要进行异常监控的代码
+ `catch`代码块：`Java`虚拟机从上至下匹配异常处理器。前面的`catch`代码块所捕获的异常类型不能覆盖后边的，否则编译器报错。
+ `finally`代码块：用来声明一段必定运行的代码。


#### 1.24 异常
在`Java`语言规范中，所有异常都是`Throwable`类或其子类的实例。`Java`的异常非为`Exception`和
`Error`两种，而`Exception`又分为`RuntimeException`和其他类型。`Error`涵盖不应捕获的异常；`Exception`涵盖程序可能需要捕获并处理的异常。`RuntimeException`与`Error`属于`Java`里的非检查异常，其他异常则属于检查异常。

#### 1.25 异常表
在编译生成的字节码中，每个方法都附带一个异常表。异常表中每个条目都代表一个异常处理器（由`from`指针、`to`指针、`target`指针以及所捕获的异常类型构成）。当程序触发异常时，`Java`虚拟机从上至下遍历异常表中的所有条目。如果未匹配异常处理器，那么会弹出当前方法对应的`Java`栈帧，并在调用者中重复这个动作。最坏情况，`Java`虚拟机需要遍历当前线程`Java`栈上所有方法的异常表。

#### 1.26 `finally`代码块
`finally`代码块的编译比较复杂，当前版本`Java`编译器的做法，是复制`finally`代码块的内容，分别放在`try-catch`代码块所有正常执行路径以及异常执行路径的出口中。如果`catch`代码块捕获了异常，并且触发了另一个异常，那么`finally`捕获并且重抛的异常是后者。也就是说原本的异常会被忽略掉。

#### 1.27 `Method.invoke`
查看 `Method.invoke`的源码，它实际上委派给`MethodAccessor`来处理。`MethodAccessor`是一个接口，有`2`个具体实现：一个是通过本地方法来实现反射调用（本地实现）；另一个使用委派模式。每个`Method`实例的第一次反射调用都会生成一个委派实现，它委派的具体实现就是一个本地实现。

#### 1.28 动态实现
`Java`的反射调用机制还设立了另一种动态生成字节码的实现（动态实现），直接使用`invoke`指令来调用目标方法。之所以采用委派实现，就是为了能够在本地实现以及动态实现中切换。

#### 1.29 `Inflation`
当某个反射调用的调用次数在`15`（通过`-Dsun.reflect.inflationThreshold=`来调整）之下时，采用本地实现；当达到`15`时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为`Inflation`。

#### 1.30 反射调用
方法的反射调用会带来不少性能开销，原因主要有`3`个：变长参数方法导致的`Object`数组，基本类型的自动装箱和拆箱，方法内联。

#### 1.31 方法句柄
`invokedynamic`底层机制的基石：方法句柄（`MethodHandle`）。方法句柄是一个强类型的、能够被直接执行的引用。该引用可以指向常规的静态方法或实例方法，也可以指向构造器或字段。它仅关心所指向方法的参数类型以及返回值类型，而不关心方法所在的类以及方法名。方法句柄的创建通过`MethodHandles.Lookup`类来完成的。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。方法句柄的调用和反射调用一样，都是间接调用，同样会遇到无法内联的问题。

### 2. 高效实现

### 3. 代码优化

### 4. 虚拟机黑科技

#### 4.0 UNSAFE
```java
// UNSAFE mechanics

private static final sun.misc.Unsafe UNSAFE;
private static final long nextOffset;

static {
    try {
        java.lang.reflect.Field theUnsafe = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        UNSAFE = (sun.misc.Unsafe) theUnsafe.get(null);
        // UNSAFE = sun.misc.Unsafe.getUnsafe();

        nextOffset = UNSAFE.objectFieldOffset(Node.class.getDeclaredField("next"));
    }
    catch (Exception e) {
        throw new Error(e);
    }
}
```
