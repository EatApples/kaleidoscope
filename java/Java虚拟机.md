###  Java 虚拟机
来源：《极客时间》专栏之《深入拆解Java虚拟机》

主讲人：郑雨迪

### 1. 基本原理
#### 字节码翻译成机器码
解释执行：逐条将字节码翻译成机器码并执行，无需等待编译。

即时编译：Just-In-Time compilation（JIT），将一个方法中包含的所有字节码编译成机器码后再执行，实际运行速度更快。建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。

HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

#### JVM 内存布局
Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。

#### 操作码
 Java 字节码指令的操作码（ opcode ）被固定为一个字节。

#### 方法区
加载后的 Java 类会被存放于方法区（ Method Area ）。实际运行时，虚拟机会执行方法区内的代码。

#### 基本类型
 Java 基本类型（8种）： boolean ， byte ， short ， char ， int ， long ， float ， double 。其中 boolean 和 char 是无符号类型。使用基本类型能够在执行效率以及内存使用两方面提升软件性能。

#### 正无穷和负无穷
在 Java 中，浮点数的正无穷和负无穷有确切数值，在内存中分别为十六进制 0x7F800000 （正无穷）， 0xFF800000 （负无穷）。

#### NaN
 NaN （ Not-a-Number ）除了 != 始终返回 true 外，所有其他比较结果都会返回 false 。

#### 栈与堆存储
在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用一个数组单元。

boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。

在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段或数组中。

#### 引用类型
 Java 引用类型细分为4种： 类 ， 接口 ， 数组类 ， 泛型参数 。泛型参数在编译过程中被擦除，数组类由 Java 虚拟机直接生成，类和接口有对应的字节流。

#### 加载
加载：在 Java 虚拟机中，类的唯一性由类加载器实例以及类的全名一同确定。加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用双亲委派模型。

#### 链接
链接：分为 验证 （确保加载的类满足 Java 虚拟机的约束条件）， 准备 （为被加载类的静态字段分配内存，构造与该类相关联的方法表）以及 解析 （解析阶段的目的，正是将 符号引用 解析成 实际引用 。如果符号引用指向未被加载的类，或未被加载类的字段或方法，那么解析将触发这个类的加载，但未必触发这个类的链接及初始化）三阶段。 Java 虚拟机规范并没有要求在链接过程中完成解析：如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。

#### 初始化
除此（满足直接赋值，被 final 修饰，类型为基本类型或字符串的静态字段，会被 Java 编译器标记为 常量值 ，初始化由 Java 虚拟机完成）之外的直接赋值操作，以及所有静态代码块中的代码，会被 Java 编译器置于同一方法 clinit 中。初始化：为标记为 常量值 的字段赋值，以及执行 clinit 方法的过程。 Java 虚拟机会通过加锁来确保类的 clinit 方法仅被执行一次。类的初始化是线程安全的，并且仅被执行一次。只有初始化完成之后，类才正式成为可执行的状态。 JVM 规范枚举了以下多种触发情况：
+ （1）当虚拟机启动时，初始化用户指定的主类；
+ （2）当遇到 new 指令时，初始化 new 指令的目标类；
+ （3）当遇到调用静态方法的指令时，初始化该静态方法所在的类；
+ （4）当遇到访问静态字段的指令时，初始化该静态字段所在的类；
+ （5）子类的初始化会触发父类的初始化；
+ （6）如果一个接口定义了 default 方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化；
+ （7）使用反射 API 对某个类进行发射调用时，初始化这个类；
+ （8）初次调用  MethodHandle  实例化时，初始化该 MethodHandle 指向的方法所在的类。

#### 重载
重载的方法在编译过程中即可完成识别，因此可以认为 Java 虚拟机中不存在重载。 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。考虑是否允许基本类型自动装拆箱与可变长参数，这个过程分为有序的三个阶段，如果前面阶段没有适配，再考虑下一阶段：00（都不允许），10（允许装拆箱但不允许可变长），11（全都允许）。如果在同一阶段找到多个适配的方法，则会选择一个最为贴切的（关键就是形参类型的继承关系）。

#### 重写
方法重写：多态的重要的一种体现方式。它允许子类在继承父类部分功能的同时，拥有自己独特的行为。重写调用会根据调用者的动态类型，来选取实际的目标方法。

#### 识别方法
 Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（ method descriptor ）（由方法的参数类型以及返回类型所构成）。注意 Java 虚拟机与 Java 语言语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中。对于调用这些方法的字节码来说，由于字节码附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

#### 方法重写判定
 Java 虚拟机关于方法重写的判定基于方法的描述符。如果子类定义了与父类中非私有、非静态同名方法的方法，那么只有当这两个方法的参数类型以及返回类型一致， Java 虚拟机才会判定为重写。

#### 桥接方法
对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写定义。

#### 静态绑定与动态绑定
 Java 虚拟机中的静态绑定指的是在解析时能够直接识别目标方法的情况；而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

#### 符号引用
在编译过程中，我们并不知道目标方法的具体内存地址。 Java 编译器会暂时用符号引用来表示该目标方法（包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符）。

#### 静态方法
静态方法可以通过子类来调用。子类的静态方法会隐藏（不是重写）父类中的同名、同描述符的静态方法。

#### 实际引用
对于静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于动态绑定的方法调用而言，实际引用则是一个方法表的索引。

#### 调用指令
具体来说， Java 字节码中与调用相关的指令共5种：
+  invokestatic ：用于调用静态方法；
+  invokespecial ： 用于调用私有实例方法、构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法；
+  invokevirtual ：用于调用非私有实例方法；
+  invokeinterface ：用于调用接口方法；
+  invokedynamic ：用于调用动态方法。

#### 虚方法调用
 invokevirtual 与 invokeinterface 这两种指令，均属于 Java 虚拟机中的虚方法调用。静态绑定包括 invokestatic 与 invokespecial 指令。如果虚方法调用指向一个标记为 final 的方法，那么 Java 虚拟机也可以静态绑定该虚方法调用。

#### 方法表
 Java 虚拟机采用空间换时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

#### 内联缓存
内联缓存是一种加快动态绑定的优化技术。它能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法。 Java 虚拟机只采用单态（还有多态，超多态，按照缓存动态类型的个数划分）内联缓存。

#### 捕获异常
捕获异常涉及如下三种代码块：
+  try 代码块：用来标记需要进行异常监控的代码
+  catch 代码块： Java 虚拟机从上至下匹配异常处理器。前面的 catch 代码块所捕获的异常类型不能覆盖后边的，否则编译器报错。
+  finally 代码块：用来声明一段必定运行的代码。


#### 异常
在 Java 语言规范中，所有异常都是 Throwable 类或其子类的实例。 Java 的异常非为 Exception 和
 Error 两种，而 Exception 又分为 RuntimeException 和其他类型。 Error 涵盖不应捕获的异常； Exception 涵盖程序可能需要捕获并处理的异常。 RuntimeException 与 Error 属于 Java 里的非检查异常，其他异常则属于检查异常。

#### 异常表
在编译生成的字节码中，每个方法都附带一个异常表。异常表中每个条目都代表一个异常处理器（由 from 指针、 to 指针、 target 指针以及所捕获的异常类型构成）。当程序触发异常时， Java 虚拟机从上至下遍历异常表中的所有条目。如果未匹配异常处理器，那么会弹出当前方法对应的 Java 栈帧，并在调用者中重复这个动作。最坏情况， Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。

#### finally 代码块
 finally 代码块的编译比较复杂，当前版本 Java 编译器的做法，是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。如果 catch 代码块捕获了异常，并且触发了另一个异常，那么 finally 捕获并且重抛的异常是后者。也就是说原本的异常会被忽略掉。

#### Method.invoke
查看  Method.invoke 的源码，它实际上委派给 MethodAccessor 来处理。 MethodAccessor 是一个接口，有 2 个具体实现：一个是通过本地方法来实现反射调用（本地实现）；另一个使用委派模式。每个 Method 实例的第一次反射调用都会生成一个委派实现，它委派的具体实现就是一个本地实现。

#### 动态实现
 Java 的反射调用机制还设立了另一种动态生成字节码的实现（动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，就是为了能够在本地实现以及动态实现中切换。

#### Inflation
当某个反射调用的调用次数在 15 （通过 -Dsun.reflect.inflationThreshold= 来调整）之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为 Inflation 。

#### 反射调用
方法的反射调用会带来不少性能开销，原因主要有 3 个：变长参数方法导致的 Object 数组，基本类型的自动装箱和拆箱，方法内联。

#### 方法句柄
invokedynamic 底层机制的基石：方法句柄（ MethodHandle ）。方法句柄是一个强类型的、能够被直接执行的引用。该引用可以指向常规的静态方法或实例方法，也可以指向构造器或字段。它仅关心所指向方法的参数类型以及返回值类型，而不关心方法所在的类以及方法名。方法句柄的创建通过 MethodHandles.Lookup 类来完成的。方法句柄的权限检查发生在创建过程中，相较于反射调用节省了调用时反复权限检查的开销。方法句柄的访问权限不取决于方法句柄的创建位置，而是取决于 Lookup 对象的创建位置。方法句柄的调用和反射调用一样，都是间接调用，同样会遇到无法内联的问题。

#### 方法句柄的调用
方法句柄的调用可分为两种，一是需要严格匹配参数类型的 invokeExact。invokeExact 会确认该 invokevirtual 指令对应的方法描述符，和该方法句柄的类型是否严格匹配。在不匹配的情况下，便会在运行时抛出异常。如果你需要自动适配参数类型，那么你可以选取方法句柄的第二种调用方式 invoke。调用方法句柄所使用的 invokeExact 或者 invoke 方法具备签名多态性的特性。它们会根据具体的传入参数来生成方法描述符。

#### invokedynamic 指令
invokedynamic 是 Java 7 引入的一条新指令，用以支持动态语言的方法调用。具体来说，它将调用点（CallSite）抽象成一个 Java 类，并且将原本由 Java 虚拟机控制的方法调用以及方法链接暴露给了应用程序。在运行过程中，每一条 invokedynamic 指令将捆绑一个调用点，并且会调用该调用点所链接的方法句柄。由于调用点仅要求方法句柄的类型能够匹配，因此这个链接是合法的。不过，这正是 invokedynamic 的目的，也就是将调用点与目标方法的链接交由应用程序来做，并且依赖于应用程序对目标方法进行验证。

#### Lambda 表达式
在 Java 8 中，Lambda 表达式也是借助 invokedynamic 来实现的。具体来说，Java 编译器利用 invokedynamic 指令来生成实现了函数式接口的适配器。对于没有捕获其他变量的 Lambda 表达式，该 invokedynamic 指令始终返回同一个适配器类的实例。对于捕获了其他变量的 Lambda 表达式，每次执行 invokedynamic 指令将新建一个适配器类实例。

#### 新建对象
在 Java 程序中，我们拥有多种新建对象的方式。除了最为常见的 new 语句之外，我们还可以通过反射机制、Object.clone 方法、反序列化以及 Unsafe.allocateInstance 方法来新建对象。

其中，Object.clone 方法和反序列化通过直接复制已有的数据，来初始化新建对象的实例字段。Unsafe.allocateInstance 方法则没有初始化实例字段，而 new 语句和反射机制，则是通过调用构造器来初始化实例字段。

#### new 指令玄机
通过 new 指令新建出来的对象，它的内存其实涵盖了所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存的。

#### 对象头
在 Java 虚拟机中，每个 Java 对象都有一个对象头（object header），这个由标记字段和类型指针所构成。其中，标记字段用以存储 Java 虚拟机有关该对象的运行数据，如哈希码、GC 信息以及锁信息，而类型指针则指向该对象的类。

在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。也就是说，每一个 Java 对象在内存中的额外开销就是 16 个字节。以 Integer 类为例，它仅有一个 int 类型的私有字段，占 4 个字节。因此，每一个 Integer 对象的额外内存开销至少是 400%。这也是为什么 Java 要引入基本类型的原因之一。

#### 压缩指针
为了尽量较少对象的内存使用量，64 位 Java 虚拟机引入了压缩指针的概念（对应虚拟机选项 -XX:+UseCompressedOops，默认开启），将堆中原本 64 位的 Java 对象指针压缩成 32 位的。

这样一来，对象头中的类型指针也会被压缩成 32 位，使得对象头的大小从 16 字节降至 12 字节。当然，压缩指针不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段，以及引用类型数组。

#### 内存对齐
内存对齐（对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8）。

默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数。如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为对象间的填充（padding）。

内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。比如说，Java 虚拟机要求 long 字段、double 字段，以及非压缩指针状态下的引用字段地址为 8 的倍数。

字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。

#### 字段重排列
字段重排列，顾名思义，就是 Java 虚拟机重新分配字段的先后顺序，以达到内存对齐的目的。Java 虚拟机中有三种排列方法（对应 Java 虚拟机选项 -XX:FieldsAllocationStyle，默认值为 1），但都会遵循如下两个规则。

其一，如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。

以 long 类为例，它仅有一个 long 类型的实例字段。在使用了压缩指针的 64 位虚拟机中，尽管对象头的大小为 12 个字节，该 long 类型字段的偏移量也只能是 16，而中间空着的 4 个字节便会被浪费掉。

其二，子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。

在具体实现中，Java 虚拟机还会对齐子类字段的起始位置。对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。

#### 虚共享
虚共享是怎么回事呢？假设两个线程分别访问同一对象中不同的 volatile 字段，逻辑上它们并没有共享内容，因此不需要同步。

然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。

Java 8 还引入了一个新的注释 @Contended，用来解决对象字段之间的虚共享（false sharing）问题。这个注释也会影响到字段的排列。Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉

#### 引用计数法
引用计数法（reference counting）。它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。

#### 可达性分析算法
这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。

那么什么是 GC Roots 呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：

+ Java 方法栈桢中的局部变量；
+ 已加载类的静态变量；
+ JNI handles；
+ 已启动且未停止的 Java 线程。

可达性分析可以解决引用计数法所不能解决的循环引用问题。

虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。

比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。

误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。

#### Stop-the-world
传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 Stop-the-world，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。

Java 虚拟机中的 Stop-the-world 是通过安全点（safepoint）机制来实现的。当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。

当然，安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。

#### 垃圾回收的三种方式
回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。

第一种是清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。

清除这种回收方式的原理及其简单，但是有两个缺点。一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。

另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。

#### TLAB
Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。

通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。

TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。

具体来说，每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。

这个操作需要加锁，线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。

接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。

如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。

#### Minor GC
当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。

Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次（HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15）。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。

总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。

Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。

#### 卡表
老年代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。这样一来，岂不是又做了一次全堆扫描呢？

HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。

在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

#### 写屏障
在 Minor GC 之前，我们并不能确保脏卡中包含指向新生代对象的引用。其原因和如何设置卡的标识位有关。

首先，如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，那么 Java 虚拟机需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作。

这个操作在解释执行器中比较容易实现。但是在即时编译器生成的机器码中，则需要插入额外的逻辑。这也就是所谓的写屏障（write barrier，注意不要和 volatile 字段的写屏障混淆）。

写屏障需要尽可能地保持简洁。这是因为我们并不希望在每条引用型实例变量的写指令后跟着一大串注入的指令。

因此，写屏障并不会判断更新后的引用是否指向新生代中的对象，而是宁可错杀，不可放过，一律当成可能指向新生代对象的引用。

虽然写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）。总的来说还是值得的。不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。这里的虚共享则是卡表中不同卡的标识位之间的虚共享问题。

为此，HotSpot 引入了一个新的参数 -XX:+UseCondCardMark，来尽量减少写卡表的操作。

#### Java 虚拟机中的垃圾回收器
Java 虚拟机的分代垃圾回收是基于大部分对象只存活一小段时间，小部分对象却存活一大段时间的假设的。

针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。

针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。

CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。

G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。

G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。

即将到来的 Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。

#### 重排序
分别为即时编译器的重排序，处理器的乱序执行，以及内存系统的重排序。

#### as-if-serial
通俗地说，就是在单线程情况下，要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果保持一致。

#### happens-before
happens-before 关系是用来描述两个操作的内存可见性的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。

在同一个线程中，字节码的先后顺序（program order）也暗含了 happens-before 关系：在程序控制流路径中靠前的字节码 happens-before 靠后的字节码。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者没有观测前者的运行结果，即后者没有数据依赖于前者，那么它们可能会被重排序。

除了线程内的 happens-before 关系之外，Java 内存模型还定义了下述线程间的 happens-before 关系。

+ 解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。

+ volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。

+ 线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。

+ 线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。

+ 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。

+ 构造器中的最后一个操作 happens-before 析构器的第一个操作。

happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。

#### Java 内存模型
Java 内存模型是通过内存屏障（memory barrier）来禁止重排序的。

对于即时编译器来说，它会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。这些内存屏障会限制即时编译器的重排序操作。然后，即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。

#### 锁
锁操作同样具备 happens-before 关系。具体来说，解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。

需要注意的是，锁操作的 happens-before 规则的关键字是同一把锁。也就意味着，如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。

#### volatile 字段
volatile 字段可以看成一种轻量级的、不保证原子性的同步，其性能往往优于（至少不亚于）锁操作。然而，频繁地访问 volatile 字段也会因为不断地强制刷新缓存而严重影响程序的性能。

在 X86_64 平台上，只有 volatile 字段的写操作会强制刷新缓存。因此，理想情况下对 volatile 字段的使用应当多读少写，并且应当只有一个线程进行写操作。

volatile 字段的另一个特性是即时编译器无法将其分配到寄存器里。换句话说，volatile 字段的每次访问均需要直接从内存中读写。

#### final 字段
final 实例字段则涉及新建对象的发布问题。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。

因此，即时编译器会在 final 字段的写操作后插入一个写写屏障，以防某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前。在 X86_64 平台上，写写屏障是空操作。

新建对象的安全发布（safe publication）问题不仅仅包括 final 实例字段的可见性，还包括其他实例字段的可见性。

当发布一个已初始化的对象时，我们希望所有已初始化的实例字段对其他线程可见。否则，其他线程可能见到一个仅部分初始化的新建对象，从而造成程序错误。

### 2. 高效实现

### 3. 代码优化

### 4. 虚拟机黑科技

#### UNSAFE
```   java
// UNSAFE mechanics

private static final sun.misc.Unsafe UNSAFE;
private static final long nextOffset;

static {
    try {
        java.lang.reflect.Field theUnsafe = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafe.setAccessible(true);
        UNSAFE = (sun.misc.Unsafe) theUnsafe.get(null);
        // UNSAFE = sun.misc.Unsafe.getUnsafe();

        nextOffset = UNSAFE.objectFieldOffset(Node.class.getDeclaredField("next"));
    }
    catch (Exception e) {
        throw new Error(e);
    }
}
```

#### JVM 参数

用户手动设置或者JVM自动设置的XX选项
```
-XX:+PrintCommandLineFlags
```
表示打印出所有XX选项的默认值
```
-XX:+PrintFlagsInitial
```
解锁任何额外的隐藏参数
```
-XX:+UnlockExperimentalVMOptions
-XX:+UnlockDiagnosticVMOptions
```
表示打印出XX选项在运行程序时生效的值
```
-XX:+PrintFlagsFinal
```
