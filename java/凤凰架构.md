### 1. 架构的演进

从大型机（Mainframe）、原始分布式（Distributed）、大型单体（Monolithic）、面向服务（Service-Oriented）、微服务（Microservice）、服务网格（SeviceMesh）到无服务（Serverless）等，技术架构确实呈现出“从大到小”的发展趋势。

### 2. RPC 需考虑

（1）服务发现：远程的服务在那里
（2）负载均衡：有多少个
（3）熔断、隔离、降级：网络出现分区、超时或者服务出错了怎么办
（4）序列化协议：方法的参数与返回结果如何表示
（5）传输协议：信息如何传输
（6）认证、授权：服务权限如何管理
（7）网络安全层：如何保证通信安全
（8）分布式数据一致性：如何令调用不同机器的服务返回相同的结果

### 3. 微服务的九个核心的业务与技术特征

（1）围绕业务能力构建
（2）分散治理
（3）通过服务来实现独立自治的组件
（4）产品化思维
（5）数据去中心
（6）强终端弱管道
（7）容错性设计
（8）演进式设计
（9）基础设施自动化

作为一个“螺丝钉”程序员，微服务架构师友善的。可是，微服务对架构者却是满满的“恶意”，对架构能力的要求已提升到史无前例的程度。

### 4. 进程间通信（IPC）

（1）管道或者具名管道
（2）信号
（3）信号量
（4）消息队列
（5）共享内存
（6）本地套接字接口

### 5. 分布式运算的八宗罪

（1）网络是可靠的
（2）延迟是不存在的
（3）带宽是无限的
（4）网络是安全的
（5）拓扑结构是一成不变的
（6）总会有一个管理员
（7）不必考虑传输成本
（8）网络都是同质化的

### 6. RPC 协议解决的三个问题

（1）如何表示数据：序列化协议
（2）如何传递数据：传输协议
（3）如何表示方法

简单、普适。高性能这三点，似乎真的很难同时满足。

### 7. REST 设计风格

REST 只能说是风格而不是规范、协议。

（1）资源（Resource）
（2）表征（Representation）
（3）状态（State）
（4）转移（Transfer）

### 8. 满足 REST 风格的系统的六大原则

（1）客户端与服务端分离
（2）无状态
（3）可缓存
（4）分层系统
（5）统一接口
（6）按需代码

### 9. REST 不足与争议

（1）面向资源的编程思想只适合做 CURD，面向过程、面向对象编程才能处理真正复杂的业务逻辑
（2）REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中
（3）REST 不利于事务支持
（4）REST 没有传输可靠性支持
（5）REST 缺乏对资源进行部分和批量处理的能力
目前，一种理论上比较优秀的可以解决以上这几类问题的方案是 GraphQL，它是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言，如何 SQL 一样，挂了个查询语言的名字，但其实 CRUD 都能做。

### 10. ACID

AID 是手段，C 是目的，前者是因，后者是果。

Redo：实现持久性
Undo：实现原子性
加锁：实现隔离性

其实不同隔离级别以及幻读、不可重复读、脏读等问题都只是表面现象，是各种锁在不同加锁时间上组合应用所产生的结果，以锁为手段来实现隔离性才是数据库表现不同隔离级别的根本原因。

MVCC 是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况，那就没有多少优化的空间了，此时加锁几乎是唯一可行的解决方案。

### 11. 透明多级分流系统

Transparent Multilevel Diversion System 有 2 条简单普适的原则：

（1）尽可能减少单点部件

（2）奥卡姆剃刀原则：最简单的系统就是最好的系统

### 12. HTTP 的发展

HTTP/1.0 就已经支持连接复用技术，即 Keep-Alive 机制。但是副作用就是“队首阻塞”。
HTTP/1.1 默认开启连接复用。
HTTP/1.x 中，HTTP 请求就是传输过程中最小粒度的信息单位。
HTTP/2 中，帧（Frame）才是最小粒度的信息单位，这项设计被称为 HTTP/2 多路复用。

### 13. QUIC

一旦在技术根基上出现问题，依赖使用者通过各种 Tricks 去解决，无论如何都难以摆脱“两害相权取其轻”的权衡困境，否则这就不是 Tricks 而是一种标准的设计模式了。

要从根本上改进 HTTP，必须直接替换 HTTP over TCP 的根基，即 TCP 协议。

QUIC（快速 UDP 网络连接）提出了连接标识符的概念，该标识符可以唯一标识客户端与服务端之间的连接，而无需依靠 IP 地址。

### 14. 负载均衡

四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。

做多级混合负载均衡，通常应是低层负载均衡在前，高层负载均衡在后。

数据链路层：改写 MAC 地址；二层负载均衡器的原理决定了它与真实服务器的通信必须是二层可达的，即必须位于同一子网当中，无法跨 VLAN。

网络层：改写 IP 地址；

传输层：改写 TCP、UDP 等协议的内容和端口；

### 15. 均衡策略

负载均衡的两大职责是“选择谁来处理用户请求”和“将用户请求转发过去”。

（1）轮询（Round Robin）
（2）权重轮询（Weighted Round Robin）
（3）随机（Random）
（4）权重随机（Weighted Random）
（5）一致性哈希（Consistency Hash）
（6）响应速度（Response Time）
（7）最小连接数（Least Connection）

### 16. 缓存

在软件开发中引入缓存的负面作用要明显大于硬件缓存带来的负面作用。

（1）引入缓存会提高系统的复杂度
（2）缓存会掩盖一些缺陷
（3）缓存会泄漏某些保密数据

冒着上述种种风险，仍然要引入缓存的理由，总结起来不外乎以下两种：

（1）为缓解 CPU 压力而引入缓存：比如把方法运行结果存储起来
（2）为缓解 I/O 压力而引入缓存：比如把对网络的读写变为对内存的访问

请注意，缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解 CPU 或 I/O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。

这里的言外之意是，如果可以通过增强 CPU、I/O 本身的性能来满足需要的话，那提升硬件往往是更好的解决方案。

### 17. 缓存风险

（1）缓存穿透：缓存空值+布隆过滤器
（2）缓存击穿：加锁同步+热点数据手动管理
（3）缓存雪崩：集群+分级+随机
（4）缓存污染：Cache Aside 模式

### 18. 架构安全性

至少包括（不限于）以下问题的具体的解决方案：
（1）认证（Authentication）：是谁，系统如何正确分辨出操作用户的真实身份（Apache Shiro / Spring Security）
（2）授权（Authorization）：有权，系统如何控制一个用户看到哪些数据（数据权限，基本只能由信息系统自主完成，并不存在能放之四海皆准的通用数据权限框架），操作哪些功能（操作权限）（RBAC / Oauth2）
（3）凭证（Credential）：证明，系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确完整且不可抵赖的（Cookie-Session / JWT，JWT 只能解决篡改的问题，不能解决泄漏的问题，令牌默认不加密）
（4）保密（Confidentiality）：系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用（为了保证信息不被黑客窃取而做的客户端加密没有太大意义；密码存储使用 BCrypt 等慢哈希算法）
（5）传输（Transport Security）：系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充（HTTPS）
（6）验证（Verification）：系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险（Java Bean Validation）

### 19. 共识与一致性

一致性是指数据不同副本之间的差异；而共识是指达成一致性的方法与过程。

分布式一致性算法，其实指的是"Distributed Consensus Algorithm"

“分布式系统中如何对某个值达成一致”的这个问题，可以划分为三个子问题来考虑，可以证明（Raft 论文）当以下三个问题同时被解决时，即等价于达成共识：
（1）如何选主（Leader Election）
（2）如何把数据复制到各个节点上（Entity Replication）
（3）如何保证过程是安全的（Safety）

“最终一致性”的分布式共识协议：Gossip 协议，但是必须明确它并不是直接与 Paxos 和 Raft 这些共识算法是等价的。

Gossip 设计了 2 种可能的消息传播模式：反熵（同步节点的全部数据，以消除各个节点之间的差异，但是会带来网络开销，消息冗余）和传谣（只发送增量数据，但可能节点状态不一致）。

### 20. 注册中心

当下，直接已服务发现、服务注册中心为目标的组件库，或者间接来实现这个目标的工具主要有以下三类：

（1）以分布式 K/V 存储框架上自己开发的服务发现，典型的代表是 ZooKeeper、Doozerd。etcd

（2）以基础设施（主要是指 DNS 服务器）来实现服务发现，典型的代表是 SkyDNS、CoreDNS

（3）专门用于服务发现的框架和工具，典型的代表是 Eureka、Consul 和 Nacos

### 21. 网关=路由器（基础职能）+过滤器（可选职能）

### 22. 网络 I/O 模型

（1）异步 I/O；
（2）同步 I/O;
包括：
阻塞 I/O；
非阻塞 I/O；
多路复用 I/O；
信号驱动 I/O；

信号驱动 I/O 与异步 I/O 的区别是“从缓冲区获取数据”这个步骤的处理，前者收到的通知是可以开始进行复制操作，在复制完成前线程处于阻塞状态，所以它仍属于同步 I/O 操作，而后者收到的通知是复制操作已经完成。

### 23. 容错策略

| 容错策略 | 优点                                               | 缺点                                       | 应用场景                                             |
| -------- | -------------------------------------------------- | ------------------------------------------ | ---------------------------------------------------- |
| 故障转移 | 系统自动处理，调用者对失败的信息不可见             | 增加调用时间，额外的资源开销               | 调用幂等服务；对调用时间不敏感                       |
| 快速失败 | 调用者有对失败的处理完全控制权；不依赖服务的幂等性 | 调用者必须处理失败逻辑                     | 调用非幂等的服务；超时阈值较低的场景                 |
| 安全失败 | 不影响主路逻辑                                     | 只适用于旁路调用                           | 调用链中的旁路服务                                   |
| 沉默失败 | 控制错误不影响全局                                 | 出错的地方将在一段时间内不可用             | 频繁超时的服务                                       |
| 故障恢复 | 调用失败后自动重试，也不影响主路逻辑               | 重试任务可能产生堆积，重试仍然可能失败     | 调用链中的旁路服务；对实时性不高的主路逻辑也可以使用 |
| 并行调用 | 尽可能在最短时间内获得最高的成功率                 | 额外消耗机器资源，大部分调用可能都是无用功 | 资源充足且对失败容忍低的场景                         |
| 广播调用 | 支持同时对批量的服务提供者发起调用                 | 资源消耗大，失败概率高                     | 只适用于批量操作的场景                               |

### 24. 可观测性

学术界一般会将可观测性分为三个更具体的方向进行研究，分别是事件日志（Logging）、链路追踪（Tracing）和聚合度量（Metrics）

日志收集：Filebeat，使用 MQ 缓冲；
存储与查询：Elasticsearch；
链路追踪：SkyWalking；
聚合：Prometheus；
展示：Grafana；

### 25. 微服务的粒度

微服务粒度的下界是它至少应满足独立性——能否独立发布、独立部署、独立运行与独立测试；内聚——强相关的功能与数据在同一个服务中处理；完备——一个服务包含至少一项业务实体与对应的完整操作。

假如只能用一个词来形容微服务解决问题的核心思想，笔者给出的答案就是“分治”，这既是微服务的基本特征，也是微服务应对复杂性的手段。
