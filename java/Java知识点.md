### NoClassDefFoundError

NoClassDefFoundError 错误的发生，是因为 Java 虚拟机在编译时能找到合适的类，而在运行时不能找到合适的类导致的错误。与 ClassNotFoundException 的不同在于，这个错误发生只在运行时需要加载对应的类不成功，而不是编译时发生。

NoClassDefFoundError 发生在 JVM 在动态运行时，根据你提供的类名，在 classpath 中找到对应的类进行加载，但当它找不到这个类时，就发生了 java.lang.NoClassDefFoundError 的错误，而 ClassNotFoundException 是在编译的时候在 classpath 中找不到对应的类而发生的错误。

### finally

不要在 finally 中使用 return 语句。

finally 总是执行，除非程序或者线程被中断。

### 静态内部类

内部类如果不是 static，它本身对外面那个类有引用关系，这一点其实从构造阶段就能看出来，你可以写段代码试试；有强引用就是 strong reachable 状态

### 4 引用

不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响

### LRU 与 LinkedHashMap

LinkedHashMap 在构造函数中可以指定链接方式：一种是按照插入的顺序组织成双链表；一种是根据访问的顺序组织成双链表，维持链表头 head 是最长时间没有访问的结点。很显然，实现 LRU 用到的应该是后一种方式

### 并发编程“串行的故事”

起源是一个硬件的核心矛盾：CPU 与内存、I/O 的速度差异，出现了 CPU 缓存，系统软件（操作系统、编译器）在解决这个核心矛盾的同时，引入了可见性、原子性和有序性问题；

简言之就是，导致可见性的原因是 CPU 缓存，导致原子性问题的原因是线程切换，导致有序性的原因是编译优化。

### Integer 的值缓存

值默认缓存 是-128 到 127 之间。

这种缓存机制并不是只有 Integer 才有，同样存在于其他的一些包装类，比如：

- Boolean，缓存了 true/false 对应实例，确切说，只会返回两个常量实例 Boolean.TRUE/FALSE。
- Short，同样是缓存了-128 到 127 之间的数值。
- Byte，数值有限，所以全部都被缓存。
- Character，缓存范围'\u0000' 到 '\u007F'

### Java 提供的默认排序算法

需要区分是 Arrays.sort()还是 Collections.sort() （底层是调用 Arrays.sort()）；什么数据类型；多大的数据集（太小的数据集，复杂排序是没必要的，Java 会直接进行二分插入排序）等。

对于原始数据类型，目前使用的是所谓双轴快速排序（Dual-Pivot QuickSort），是一种改进的快速排序算法，早期版本是相对传统的快速排序。

而对于对象数据类型，目前则是使用 TimSort，思想上也是一种归并和二分插入排序（binarySort）结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是查找数据集中已经排好序的分区（这里叫 run），然后合并这些分区来达到排序的目的。

另外，Java 8 引入了并行排序算法（直接使用 parallelSort 方法），这是为了充分利用现代多核处理器的计算能力，底层实现基于 fork-join 框架，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点；但是，当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。

### 有序 Map

虽然 LinkedHashMap 和 TreeMap 都可以保证某种顺序，但二者还是非常不同的。

LinkedHashMap 通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的 put、get、compute 等，都算作“访问”。

对于 TreeMap，它的整体顺序是由键的顺序关系决定的，通过 Comparator 或 Comparable（自然顺序）来决定。

### Java IO 方式

首先，传统的 java.io 包，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是同步、阻塞的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。

第二，在 Java 1.4 中引入了 NIO 框架（java.nio 包），提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。

第三，在 Java 7 中，NIO 有了进一步的改进，也就是 NIO 2，引入了异步非阻塞 IO 方式，也有很多人叫它 AIO（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单 理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。

Selector 是基于底层操作系统机制，不同模式、不同版本都存在区别：Linux 上依赖于 epoll。Windows 上 NIO2（AIO）模式则是依赖于 iocp。

### 构建器模式（Builder）

通常会被实现成 fluent 风格的 API，也有人叫它方法链。

使用构建器模式，可以比较优雅地解决构建复杂对象的麻烦，这里的“复杂”是指类似需要输入的参数组合较多，如果用构造函数，我们往往需要为每一种可能的输入参数组合实现相应的构造函数，一系列复杂的构造函数会让代码阅读性和可维护性变得很差。
