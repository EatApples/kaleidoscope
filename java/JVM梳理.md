```
书籍：《深入理解Java虚拟机：JVM高级特性与最佳实践》
作者：周志明
```

# 读书笔记之 JVM 梳理

### 1. Java 至今流行的原因？

从 1995 年 Java 诞生开始，新的编程语言不断推陈出新，但是 Java 语言的热度一直名列前茅。这里从个人角度，尝试解释 Java 流行的原因。

（1）JVM

首先，肯定是各种硬件平台上的 Java 虚拟机。在硬件和源文件之间增加一个中间层 JVM，屏蔽了底层硬件的区别，达到了“一次编写，到处运行”的效果（横向-跨平台）。

Java 编译器分为前端编译器和后端编译器。前端编译器（javac）将源文件（java 文件）编译成 Java 字节码（class 文件），后端编译器（C1、C2 等）将字节码编译成机器码。这一步与具体的 JVM 的实现有关，不同的硬件平台有不同的机器指令，当然也需要有对应的 JVM。

字节码是连接源码和机器指令的桥梁，这样带来一个好处：其他非 java 语言只要能实现前端编译器，将源码编译成符合 JVM 规范的字节码，就能在 JVM 上运行。

JVM 是 Java 虚拟机规范，约束边界，但不指定具体实现，这就为多样性带来了可能。HotSpotVM 只是 JVM 的一种，但不是全部，用户可以有多种选择。

JVM 这种“前后端分离”的设计（指源码-前端编译器-字节码-后端编译器-机器码），解耦合，可扩展，正是 Java 流行的首要原因。

（2）面向对象

考察编程语言的发展，大概就是从面向过程向面向对象转变，最终走向面向函数。Java 立足于面向对象，逐步走向面向函数。

虽然编程语言表现形式不一，但是从机器指令（或汇编代码）来看，大家都是一堆堆二进制文件，用的都是冯·诺依曼结构，都不可能超越丘奇-图灵理论（可计算性理论）：没啥不同。

新的语言有后发优势，但肯定有一个被大众接受的过程。Java 语言的面向对象自然而然（所有类的父类都是 Object），入门门槛较低：没有对象的话，请先 new 一个。

（3）GC

就像人吃完饭后，不想洗碗一样，大多数程序员不想在编码过程中还要考虑对象的释放（以免内存泄漏）。

Java 有完善的内存回收机制，解放了程序员的生产力。

（4）兼容

穷则独善其身，达则兼济天下。编程世界中，硬件和软件总在发展。如果某一天你写的代码在新环境下不能用，而不得不重写一次，就像嚼完的甘蔗再嚼一遍一样，索然无味。

Java 保持兼容的能力（虽然某些逻辑已废弃，但仍然保留），这种“透明性”（指对程序员无感知）赋予了“一次编写，到处运行”新的含义（纵向-跨版本）。

（5）spring

这里其实说的是 Java 的开发框架，包括但不限于 JDK 自带的 API 类库（比如 JUC 并发包），SpringCloud，SpringBoot 等。还有各种流行的 Java 开源软件，比如 RocketMQ，Zookeeper 等。

这些好用的软件或最佳实践，降低了开发难度，减少了开发时间。Java 的生态丰富多样，这样才不至于“灭绝”。

总之，Java 的春天还远未结束。

### 2. OOM 会发生在哪些地方？

内存动态分配和垃圾回收技术是一种“围城”，欲戴王冠，必承其重。

Java 虚拟机运行时数据区，包括以下几个部分：

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

按照不同的维度，可以做不同的划分。

JVM 是基于栈的指令集架构，数据区简单可分为栈和堆。

栈包括：虚拟机栈，本地方法栈。

其中，只有虚拟机栈，本地方法栈和程序计数器是线程隔离的，其他部分（方法区，堆，本地库接口，执行引擎）由所有线程共享。

（1）程序计数器是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域（其实没有必要，就一个计数器，简单理解就是一个指针，指向将要执行的字节码的地址）

（2）虚拟机栈描述的是 java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度（递归调用方法时出现），将抛出栈溢出错误（StackOverflowError）。如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存，则会抛出 OOM。

（3）本地方法栈与虚拟机栈一样，只不过调用的方法是 Native 方法（指非 java 方法），也会抛出栈溢出和 OOM。

（4）堆被所有线程共享，在虚拟机启动时创建。JVM 规范中说所有的对象实例以及数组都要在堆上分配（栈上分配、标量替换等优化技术带来了一些改变）。如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出 OOM。

（5）方法区与堆一样，被线程共享（称之为非堆），存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。原则上，如何实现方法区属于虚拟机的实现细节，不受虚拟机规范约束（HotSpotVM 使用永久代来实现方法区）。当方法区无法满足内存分配需求时，将抛出 OOM（运行时常量池是方法区的一部分，例如 String#intern 方法可能造成 OOM）。

（6）直接内存（通常意义上的内存）不是 JVM 运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，但是这部分内存也会被频繁的使用（NIO 会使用 Native 函数库直接分配堆外内存），在扩展时，由于受机器总内存的限制，可能出现 OOM。

### 3. new Object 时发生了什么？

（1）虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载，解析与初始化。

（2）如果没有，将进行类加载过程。

（3）在类加载检查通过后，JVM 将为新生对象分配内存。

对象所需内存在类加载完后便可完全确定。为对象分配控件的任务等同于把一块确定大小的内存从 java 堆中划分出来。

内存分配方式有“指针碰撞”（堆中内存是规整的，只要移动指针即可）和“空闲列表”（堆中内存不规整）。

堆是否规整，由垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial，ParNew 等带 Compact 过程的收集器，系统采用指针碰撞；而使用 CMS 这种基于 Mark-Sweep 算法的收集器，采用空闲列表。

内存的分配也要考虑线程安全（因为堆对所有线程可见），解决方案有 2 种：一是分配时使用同步，例如使用 CAS。二是使用 TLAB（Thread Local Allocation Buffer），线程私有，无需同步。

（4）内存分配之后，JVM 需要将该内存初始化为零值（不包括对象头），保证对象的实例字段在 java 代码中可以不赋初值就能直接使用（就是给定默认值，例如 int 就是 0，引用类型就是 null）。

（5）JVM 进行后续的设置，例如将对象是哪个类的实例，对象的 GC 分代年龄等信息存放在对象头。

（6）此时一个对象已经诞生，但还未执行\<init\>方法。一般来说，执行 new 指令之后会接着执行\<init\>方法，把对象按照程序员的意愿进行初始化，这样，一个真正可用的对象才算完全产生出来。

### 4. 对象的内存布局？

对象在内存中存储的布局可分为 3 部分：对象头，实例数据和对齐填充。

（1）HotSpotVM 对象头包括 2 部分信息：MarkWord 和类型指针。

MarkWord 存储对象自身的运行时数据：哈希码，GC 分代年龄，锁状态标志，偏向线程 ID 等。MarkWord 大小为 1 个字（32 位虚拟机为 32bit，64 位虚拟机为 64bit），会根据对象的状态复用存储空间。

类型指针指向对象的类元数据，虚拟机根据这个指针来确定这个对象是哪个类的实例。如果对象是一个 java 数组，那对象头中还有一块用于记录数组长度的数据。

（2）实例数据是对象真正存储的有效信息，即各种类型的字段内容。无论从父类继承下来的，还是在子类（我理解为当前类）中定义的，都需要记录起来。

这部分的存储顺序会受到虚拟机分配策略参数和源码中定义顺序的影响。HotSpotVM 的默认策略是相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类（当前类）的之前。

（3）对齐填充不是必然存在，也没有特别的含义，仅仅起占位符的作用。HotSpotVM 要求对象的大小是 8 字节的整数倍（内存对齐）。

### 5. 对象的访问定位？

使用对象时，需要从栈上的 reference 数据来操作堆上的具体对象。JVM 规范只规定了一个指向对象的引用，对象的访问方式取决于 JVM 的实现。目前主流的访问方式有 2 种：使用句柄和直接指针。

使用句柄，堆中将会划分出一块内存作为句柄池。reference 中存的就是对象的句柄地址，而句柄包括 2 个指针：一个指向对象实例数据，一个指向对象类型数据。

HotSpotVM 采用的是直接指针，reference 直接指向对象的地址，在对象头中存储了类型指针。

使用句柄的最大好处就是 reference 存储的是稳定的句柄地址，在对象移动时，只会改变句柄中的实例数据指针，而 reference 本身不会修改。

直接指针的优势是访问速度更快，因为节省了一次指针定位的开销。

### 6. 如何内存回收？

GC 需要完成的 3 个事情：

- WHAT：哪些内存需要回收？
- WHEN：何时回收?
- HOW：如何回收？

（1）WHAT：死对象需要回收。

对象已死怎么判断？采用引用计数法或可达性分析算法（引用链）。

引用计数法不能解决循环依赖的问题，故不采用。

在 Java 中，可作为 GCRoot 的对象有以下几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；

在 java 中按照对 GC 的影响，将引用分为强软弱虚 4 种。

方法区（HotSpotVM 中的永久代）中的废弃常量和无用的类也可以回收。

无用的类，必须满足 3 个条件：

- 无实例：该类的所有实例都已经被回收，即堆中不存在该类的任何实例；
- 无加载器：加载该类的 classLoader 已经被回收；
- 无类反射：该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过类反射访问该类的方法

虚拟机可以对无用的类进行回收，但到底做不做，由虚拟机决定。

（2）WHEN：安全点时回收。

基于可达性分析的算法，需要确保引用在某个瞬间不再变化，看起来像冻结一样，即 STW（Stop The World）。

程序执行时，并非在所有地方都能停下来开始 GC，只有到达安全点时才能暂停。安全点是特定的位置，以“是否具有让程序长时间执行的特征”为标准选定，例如方法调用，循环跳转等。

GC 发生时，让所有线程跑到最近的安全点再停顿下来（也可进入安全区域：在安全区域中，引用关系不再发生变化）。

如何停顿？有 2 种方案 ：抢占式中断和主动式中断。

抢占式中断在 GC 发生时，首先把所有线程全部中断，然后让它们跑到安全点。

主动式中断不直接对线程进行操作，只是设置一个 GC 标志，让各个线程主动去轮询，为真时线程就主动挂起。

（3）HOW：分代收集算法。

根据对象的存活周期的不同，将内存划分为几块，一般分为新生代和老年代。根据各个年代的特点，采取适当的收集算法。

标记-清除算法：最为基础，分为标记与清除 2 个阶段。首先标记出需要回收的对象，然后统一回收被标记的对象。不足之处有 2 个：一是效率问题，标记和清除的效率不高（可以通过并发标记，多线程来提速）；二是空间问题，标记清楚后有内存碎片（可以通过整理来避免）

复制算法：将内存分为大小相等的 2 块，每次只使用其中一块。当内存回收时，将存活对象复制到另一块，释放当前块。实现简单，运行高效，但是空间利用率只有 50%（HotSpotVM 按照 1:1:8 划分为 3 块，使用率达到了 90%）

标记-整理算法：类似标记-清除算法，但后期不是直接清除，而是让所有存活对象都向一端移动，然后清理端边界以外的内存。

在新生代，对象朝生夕灭，选用复制算法。

老年代对象存活率高，必须使用“标记-清除”或“标记-整理”算法。

### 7. 垃圾收集器如何组合？

如果说收集算法（复制，标记-清除，标记整理等）是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

这里以 HotSpotVM 的实现为例，说下垃圾收集器在不同年代是如何配合使用的。

注意：没有万能的收集器，也没有最好的收集器，只有适合的收集器。

在新生代：Serial，ParNew，Parallel Scavenge

在老年代：Serial Old，Parallel Old，CMS

横跨新生代与老年代：G1

（1）Serial：单线程-复制

单线程的意义不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更多的是说明它会 STW，直到收集结束。

Serial 是虚拟机运行在 Client 模式（采用 C1 编译器）下的默认新生代收集器：简单而高效。

（2）ParNew：多线程-复制

ParNew 是 Serial 的多线程版本（多线程收集），运行在 Server 模式（采用 C2 编译器）下的首选新生代收集器。

除了 Serial 外，只有 ParNew 才能与 CMS 配合。

在多 CPU 的机器上，表现效果整体优于 Serial。

（3）Parallel Scavenge：多线程-吞吐量优先-复制

Parallel Scavenge 的目标是达到一个可控制的吞吐量，即吞吐量优先。

吞吐量=运行代码的时间 / (运行代码的时间 + 垃圾收集的时间)

与 ParNew 不同，Parallel Scavenge 还会自适应调节策略，动态调整参数以达到最合适的停顿时间或最大的吞吐量。

（4）Serial Old：单线程-标记-整理

Serial Old 是 Serial 的老年代版本，有 2 个作用：一是在 JDK15 之前配合 Parallel Scavenge 使用（JDK16 时出现了 Parallel Old）；二是作为 CMS 的后备预案。

（5）Parallel Old：多线程-吞吐量优先-标记-整理

Parallel Old 是 Parallel Scavenge 的老年代版本，直到这时，吞吐量优先的新老组合才名副其实。

（6）CMS：多线程-标记-清除

CMS 是以获取最短停顿时间为目标的收集器，分为：

- 初始标记（需 STW）
- 并发标记
- 重新标记（需 STW）
- 并发清除

4 个步骤。

CMS 远达不到完美，有以下 3 个明显的缺点：

- CPU 敏感，占 CPU
- 无法处理浮动垃圾，如果出现 Concurrent Mode Failure，需要 Serial Old 来救场
- 基于标记-清除，需要处理碎片问题

  （7）G1：标记-整理-考虑停顿时间，优先回收价值最大的 Region

  在 G1 之前，其他收集器进行收集的范围都是整个新生代和老年代。使用 G1 之后，java 堆的内存布局发生变化：它将整个堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但这两者之间不再物理隔离，它们都是一部分 Region（不需要连续） 的集合。

G1 的特点：

- 并行与并发：利用多 CPU 的优势，缩短 STW 的时间
- 分代收集：采用不同方式处理新建对象与旧对象
- 空间整合：整体上看是标记-整理，从 Region 上看是复制，总之不会产生内存碎片
- 可预测的停顿：能建立可预测的停顿模型，能指定在 M 毫秒时间片内，进行垃圾收集的时间小于 N 毫秒

G1 的收集步骤，大致与 CMS 类似：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

### 8. GC 日志如何理解？

注意 2 点:

（1）GC 日志开头的[GC][fullgc] 说明了垃圾回收的停顿类型，而不是用来区分新生代还是老年代！如果有 Full，说明发生了 STW

（2）GC 时间这块，user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，而 real 指的是从开始到结束的耗时，包括非运算等待耗时，例如等待磁盘 IO，等待线程阻塞等。一般情况下，real 会大于 user 与 sys。但如果多核，则 CPU 时间会叠加，可能导致 user 或 sys 会超过 real

### 9. 内存分配策略？

自动内存管理最终可总结为解决了 2 个问题：给对象分配内存，以及回收分配给对象的内存。

回收的策略已经提过，即分代收集：各种垃圾收集器的组合。

分配的规则并不固定，取决于垃圾回收器的组合，还有虚拟机与内存相关的参数设置。但还是有几条最普遍的内存分配规则：

- 对象优先在 Eden 分配
- 大对象直接进入老年代
- 长期存活的对象进入老年代（何谓长期？指的是经过 15 次（默认值） GC 还存活，则可晋级）

### 多线程是如何实现的？

JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现。
