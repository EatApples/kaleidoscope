### 1. 知己知彼

如果你了解一门语言的不足之处和局限性，当你遇到某个语言特性不可用时，就不会被卡住，以致无法继续。

同时，因为你已经知晓其局限性，所以就可以更好地进行程序设计。

### 2. 抽象

创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。

对象具有状态、行为及标识。

隐藏代码的具体实现可以有效减少程序 BUG。

### 3. 单根层次结构

这个终极基类的名字是 Object。

单根层次结构有利于实现垃圾收集器（garbage collector）。

### 4. 内存管理

栈通常利用汇编指令向下或向上移动栈指针来管理内存，而堆何时分配内存则取决于内存机制的实现方式。

Java 只允许动态分配内存。

### 5. 数据保存在哪里

寄存器。栈。堆。常量存储。非 RAM 存储。

### 6. Java 9 之后

new Integer() 效率低于 Integer.valueOf()

JDK17 最终引入密封（sealed）类和密封接口，因此基类或接口可以限制自己能派生出哪些类。

record 定义的是希望成为数据传输对象的类。当使用 record 关键字时，编译器会自动生成：不可变字段；一个规范的构造器；每个元素都有访问器方法；equals；hashCode；toString。

推荐使用 Java8 中的 SplittableRandom，不仅支持并行操作，而且还能生成更高质量的随机数。

### 7. 标签

一定要记住，在 Java 里使用标签的唯一理由是你使用了嵌套循环，而且你需要使用 break 或 continue 来跳出多层的嵌套。

### 8. 重载

每个重载方法必须有独一无二的参数类型列表。

### 9. 初始化顺序

即使分散到方法定义之间，变量定义仍然会在任何方法（包括构造器）调用之前就初始化。

初始化的顺序是从静态字段开始，然后是非静态字段。

基类的构造器被调用，递归地重复此步骤，一直到构造层次的根。根类先被构造，然后是下一个子类，一次类推，直到最底层的子类。

然后按照声明的顺序来初始化成员。

最后执行子类构造器的方法体。

### 10. 模块

在 Java 9 之前，Java 程序会依赖整个 Java 库。

尽管包访问似乎提供了有效的隐藏，使用类不能在包外使用，但是可以使用反射来规避。

Java 9 最终引入模块，它解决了这 2 个问题。

### 11. 委托

虽然 Java 里有没提供直接支持，但除了组合和继承外，还有第三种关系叫作委托。

继承是用来表示“is-a”关系的，而组合是用来表示“has-a”关系的。

尽管在面向对象编程中非常强调继承，但当开始时，一般应该优先使用组合（也有可能是委托），并且仅在必要时才使用继承。

### 12. final

final 使用引用恒定不变。一旦引用被初始化为一个对象，它就永远不能被更改为指向另一个对象了。但是，对象本身是可以修改的。

类中的任何 private 方法都是隐式的 final，因为你不能访问一个 private 方法，也不能重写它。

只有非 private 的方法可以被重写。

### 13. 动态绑定

绑定发生在运行时，并基于对象的类型。

Java 中所有的方法绑定都是后期绑定（动态绑定），除非方法是 static 或 final 的（private 方法隐式为 final）。这意味着通常不需要你来决定是否需要执行后期绑定——它会自动发生。

### 14. 构造器

在构造器中，你必须能确定所有成员都已构建。保证这一点的唯一方法是首先调用基类的构造器。

编写构造器有一个很好的准则：用尽可能少的操作使对象进入正常的状态，如果可以避免的话，请不要调用此类中的任何其他方法。

只有基类中的 final 方法可以在构造器中安全调用（这也适用于 private 方法，它们默认就是 final 的）。

### 15. 向上转型

向上转型总是安全的，因为基类不可能比子类有更多的接口。

### 16. 抽象类与接口

| 特性               | 接口                         | 抽象类                                   |
| ------------------ | ---------------------------- | ---------------------------------------- |
| 组合               | 可以在新类中组合多个接口     | 只能继承一个抽象类                       |
| 状态               | 不能包含字段（静态字段除外） | 可以包含字段，非抽象方法可以引用这些字段 |
| 默认方法与抽象方法 | 默认方法不需要在子类中实现   | 抽象方法必须在子类中实现                 |
| 构造器             | 不能有构造器                 | 可以有构造器                             |
| 访问权限控制       | 隐式的 public                | 可以为 protected 或包访问权限            |

优先使用类而不是接口。

### 17. 内部类

当创建一个内部类时，这个内部类的对象中会隐含一个链接，指向用于创建该对象的外围对象。

通过该链接，无须任何特殊条件，内部类对象就可以访问外围对象的成员。

此外，内部类拥有对外围对象所有元素的访问权。

除非已经有了一个外部类的对象，否则创建内部类对象是不可能的。这是因为内部类的对象会暗中连接到用于创建它的外部类对象。

局部内部类：在方法的作用域内创建一个完整的类。

匿名内部类：这个类没有名字。

局部内部类允许我们创建该类的多个对象，而匿名内部类通常用于返回该类的一个实例。

嵌套类：将内部类设置为 static（不需要一个外部类来创建嵌套类对象；无法从嵌套类对象内部访问非 static 的外部类对象）

为什么需要内部类：每个内部类都可以独立地继承自一个实现。因此，外部类是否已经继承了某个实现，对内部类并没有限制。如果没有内部类提供的这种事实上能继承多个具体类或抽象类的能力，有些设计或编程问题会非常棘手。

### 18. 迭代器

迭代器（也是一种设计模式）是一个对象，它可以在序列中移动，并用来选择该序列中的每个对象，而使用它的程序员不用知道或者关系序列的底层结构。

迭代器统一了对集合的访问。

for-in 语句可以配合数组或者任何实现了 Iterable 接口的类使用。

### 19. 声明式编程

声明式编程是一种编程风格，我们说明想要完成什么（What），而不是指明怎么做（How）。

排序可以指定 DESC：Collections.reverseOrder();

### 20. 异常丢失

finally 中抛出的异常会覆盖 try 中的异常；
在 finally 子句中执行 return，会丢失异常。

### 21. try-with-resources

try 子句中（也就是括号中）创建的对象，必须实现 java.lang.AutoCloseable 接口，该接口只有一个 close 方法。

### 22. 异常使用指南

（1）尽可能使用 try-with-resources
（2）要在恰当的层次处理问题（除非知道怎么处理，否则不要捕捉异常）
（3）可以使用异常来修复问题，并重新调用引发异常的方法
（4）可以选择做好补救措施，然后继续，不再重新尝试引发异常的方法
（5）可以借助异常处理的过程计算出某个结果，以替代该方法生成的值
（6）可以在当前上下文把能做的事情都做了，然后将相同的异常重新抛出，使其进入更上层的上下文中
（7）可以在当前上下文把能做的事情都做了，然后重新抛出一个不同的异常，使其进入更上层的上下文中
（8）使用异常来终止程序
（9）使用异常来简化问题
（10）使用异常让我们的库和程序更安全

### 23. 重构的基础

（1）测试（通常来说，最低要求是要有 JUnit 测试），因此你可以确保自己的重构不会改变代码的行为
（2）构建自动化，从而容易构建代码并运行所有测试
（3）版本控制，这样就可以随时提供或回退到可工作的代码版本

没有这三个系统，重构几乎是不可能的。

### 24. 反射

反射：在运行时，确定对象的类型。

当没有其他信息告诉你对象类型的时候，在向下转型之前使用 instanceof 很重要。

instanceof 有一个相当严格的限制：只能将其与命名类型进行比较，而不能与一个 Class 对象进行比较。

Class.isInstance() 方法提供了一种动态验证对象类型的方式。

当使用反射与未知类型的对象打交道时，JVM 会查看这个对象，确定它属于哪个特定的类。

看来没有任何方法可以阻止反射进入并调用非公共访问权限的方法。对于字段，甚至是 private 字段，也是如此。

使用多态而不是反射。

### 25. 泛型

泛型代码内部不存在有关泛型参数类型的可用信息。

Java 泛型是通过类型擦除实现的。任何需要在运行时知道确切类型的操作都无法进行。

类型擦除的核心初衷是，希望让泛型的调用方程序可以依赖于非泛型化库正常使用，反之亦然。这通常称为迁移兼容性。

无法创建泛型数组，通用的解决方案是不管在何处，都使用 ArrayList 来创建泛型数组。

因为数组是完全在语言内部定义的，因此可以同时拥有编译时和运行时的内建检查。

### 26. 排序

Java 标准库中的排序算法，已经为各种类型做了最优设计——对基本类型使用快速排序，对对象类型使用稳定的归并排序。


