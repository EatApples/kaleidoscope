# 阿里巴巴Java开发手册阅读笔记

1. 类名使用 `UpperCamelCase` 风格

2. 方法名、参数名、成员变量、局部变量都统一使用 `lowerCamelCase` 风格，必须遵从驼峰形式

3. 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长

4. 抽象类命名使用 `Abstract` 或 `Base` 开头； 异常类命名使用 `Exception` 结尾； 测试类命名以它要测试的类名开始，以 `Test` 结尾

5. `POJO` 类中布尔类型的变量，都不要加 `is` 前缀，否则部分框架解析会引起序列化错误

6. 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式

7. 如果模块、 接口、类、方法使用了设计模式，在命名时体现出具体模式

8. 接口类中的方法和属性不要加任何修饰符号（`public` 也不要加） ，保持代码的简洁性，并加上有效的 `Javadoc` 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量

9. 如果是形容能力的接口名称，取对应的形容词为接口名（通常是`–able` 的形式）

10. 枚举类名建议带上 `Enum` 后缀，枚举成员名称需要全大写，单词间用下划线隔开

11. `Service/DAO` 层方法命名规约
```
    1） 获取单个对象的方法用 get 作前缀。

    2） 获取多个对象的方法用 list 作前缀。

    3） 获取统计值的方法用 count 作前缀。

    4） 插入的方法用 save/insert 作前缀。

    5） 删除的方法用 remove/delete 作前缀。

    6） 修改的方法用 update 作前缀。
```
12. 不允许任何魔法值（即未经预先定义的常量） 直接出现在代码中

13. 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。
```
    1） 跨应用共享常量：放置在二方库中，通常是 `client.jar` 中的 `constant` 目录下。

    2） 应用内共享常量：放置在一方库中， 通常是子模块中的 constant 目录下。

  反例： 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：
    类 A 中： public static final String YES = "yes";
    类 B 中： public static final String YES = "y";
    A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。

    3） 子工程内部共享常量：即在当前子工程的 constant 目录下。

    4） 包内共享常量：即在当前包下单独的 constant 目录下。

    5） 类内共享常量：直接在类内部 private static final 定义。
```
14. 所有的覆写方法，必须加 `@Override` 注解

15. `Object` 的 `equals` 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 `equals`

16. 所有的相同类型的包装类对象之间值的比较，全部使用 `equals` 方法比较

17. 使用索引访问用 `String` 的 `split` 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 `IndexOutOfBoundsException` 的风险

18. `final` 可以声明类、成员变量、方法、以及本地变量，下列情况使用 `final` 关键字：
```
    1） 不允许被继承的类，如： String 类。

    2） 不允许修改引用的域对象，如： POJO 类的域变量。

    3） 不允许被重写的方法，如： POJO 类的 setter 方法。

    4） 不允许运行过程中重新赋值的局部变量。

    5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构
```
19. `subList` 返回的是 `ArrayList` 的内部类 `SubList`，并不是 `ArrayList` ，而是 `ArrayList` 的一个视图，对于 `SubList` 子列表的所有操作最终会反映到原列表上

20. 扩展说一下` PECS(Producer Extends Consumer Super)` 原则： 第一、 频繁往外读取内容的，适合用`<? extends T>`。 第二、 经常往里插入的，适合用`<? super T>`

21. 不要在 `foreach` 循环里进行元素的 `remove/add` 操作。 `remove` 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁。

22. 在 `JDK7` 版本及以上， `Comparator` 要满足如下三个条件，不然 `Arrays.sort`，`Collections.sort` 会报 `IllegalArgumentException` 异常。说明： 三个条件如下
```
    1） x， y 的比较结果和 y， x 的比较结果相反。

    2） x>y， y>z， 则 x>z。

    3） x=y， 则 x， z 比较结果和 y， z 比较结果相同。
```
23. 集合初始化时， 指定集合初始值大小

24. 使用 `entrySet` 遍历 `Map` 类集合 `KV`，而不是 `keySet` 方式进行遍历。

    说明： `keySet` 其实是遍历了 `2` 次，一次是转为 `Iterator` 对象，另一次是从 `hashMap` 中取出 `key` 所对应的 `value`。而 `entrySet` 只是遍历了一次就把 `key` 和 `value` 都放到了 `entry` 中，效率更高。如果是 `JDK8`，使用 `Map.foreach` 方法

25. 高度注意 `Map` 类集合 `K/V` 能不能存储 `null` 值的情况，如下表格：

| 集合类            | Key           | Value         | Super       | 说明                   |
| ----------------- | ------------- | ------------- | ----------- | ---------------------- |
| Hashtable         | 不允许为 null | 不允许为 null | Dictionary  | 线程安全               |
| ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 锁分段技术（JDK8:CAS） |
| TreeMap           | 不允许为 null | 允许为 null   | AbstractMap | 线程不安全             |
| HashMap           | 允许为 null   | 允许为 null   | AbstractMap | 线程不安全             |


26. 合理利用好集合的有序性`(sort`)和稳定性(`order`)，避免集合的无序性(`unsort`)和不稳定性(`unorder`)带来的负面影响。

    说明： 有序性是指遍历的结果是按某种比较规则依次排列的。 稳定性指集合每次遍历的元素次序是一定的。 如：

| 数据结构  | 稳定性/有序性  |
| --------- | -------------- |
| ArrayList | order/unsort   |
| HashMap   | unorder/unsort |
| TreeSet   | order/sort     |

27. 利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains` 方法进行遍历、对比、 去重操作

28. 获取单例对象需要保证线程安全，其中的方法也要保证线程安全

29. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯

30. 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

    说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

31. 线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

32. `SimpleDateFormat` 是线程不安全的类，一般不要定义为 `static` 变量，如果定义为 `static`，必须加锁，或者使用 `DateUtils` 工具类

33. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁； 能锁区块，就不要锁整个方法体； 能用对象锁，就不要用类锁

34. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁

35. 如果每次访问冲突概率小于 `20%`，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 `3` 次

36. 多线程并行处理定时任务时， `Timer` 运行多个 `TimeTask` 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 `ScheduledExecutorService` 则没有这个问题

37. 使用 `CountDownLatch` 进行异步转同步操作，每个线程退出前必须调用 `countDown` 方法，线程执行代码注意 `catch` 异常，确保 `countDown` 方法被执行到，避免主线程无法执行至 `await` 方法，直到超时才返回结果。

38. 子线程抛出异常堆栈，不能在主线程 `try-catch` 到

39. 在 `JDK7` 之后，可以直接使用 `API` `ThreadLocalRandom`， 而在 `JDK7` 之前， 需要编码保证每个线程持有一个实例

40. `volatile` 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题

41. `HashMap` 在容量不够进行 `resize` 时由于高并发可能出现死链，导致 `CPU` 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险

42. `ThreadLocal` 无法解决共享对象的更新问题， `ThreadLocal` 对象建议使用 `static` 修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量

43. 在一个 `switch` 块内，每个 `case` 要么通过 `break/return` 等来终止，要么注释说明程序将继续执行到哪一个 `case` 为止； 在一个 `switch` 块内，都必须包含一个 `default` 语句并且放在最后，即使空代码

44. 在 `if/else/for/while/do` 语句中必须使用大括号。 即使只有一行代码，避免采用单行的编码方式： `if (condition) statements`

45. 在高并发场景中，避免使用`等于`判断作为中断或退出的条件

46. 表达异常的分支时， 少用 `if-else` 方式， 这种方式可以改写成：
```java
if (condition) {
  ...
  return obj;
}
// 接着写 else 的业务逻辑代码;
```
47. 不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性

48. 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 `try-catch` 操作（这个 `try-catch` 是否可以移至循环体外）

49. 避免采用取反逻辑运算符

50. 接口入参保护，这种场景常见的是用作批量操作的接口

51. 下列情形，需要进行参数校验：
```
    1） 调用频次低的方法。

    2） 执行时间开销很大的方法。 此情形中， 参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。

    3） 需要极高稳定性和可用性的方法。

    4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。

    5） 敏感权限入口
```
52. 下列情形， 不需要进行参数校验：
```
    1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。

    2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。

    3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数
```
53. 类、类属性、类方法的注释必须使用 `Javadoc` 规范，使用`/**内容*/`格式，不得使用`// xxx` 方式；方法内部单行注释，在被注释语句上方另起一行，使用`//`注释。方法内部多行注释
使用`/* */`注释，注意与代码对齐

54. 所有的抽象方法（包括接口中的方法） 必须要用 `Javadoc` 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。

    说明： 对子类的实现要求，或者调用注意事项，请一并说明

55. 所有的类都必须添加创建者和创建日期

56. 所有的枚举类型字段必须要有注释，说明每个数据项的用途

57. 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可

58. 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改

59. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位

60. 特殊注释标记，请注明标记人与标记时间
```
    1） 待办事宜（TODO） :（标记人，标记时间， [预计处理时间]）
        表示需要实现，但目前还未实现的功能。

    2） 错误，不能工作（FIXME） :（标记人，标记时间， [预计处理时间]）
        在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。
```
61. 异常不要用来做流程控制，条件控制

62. `catch` 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 `catch` 尽可能进行区分异常类型，再做对应的异常处理

63. 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之

64. 有 `try` 块放到了事务代码中， `catch` 异常后，如果需要回滚事务，一定要注意手动回滚事务

65. `finally` 块必须对资源对象、流对象进行关闭，有异常也要做 `try-catch`
如果 `JDK7` 及以上，可以使用 `try-with-resources` 方式

66. `finally` 块中的 `return` 返回后方法结束执行，不会再执行 `try` 块中的 `return` 语句

67. 捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类

68. 方法的返回值可以为 `null`，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 `null` 值

69. 使用 `JDK8` 的 `Optional` 类来防止 `NPE` 问题

70. 避免出现重复的代码（`Don’t Repeat Yourself`） ，即 `DRY` 原则

71. `logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);`

72. 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。

73. 后台输送给页面的变量必须加`$!{var}`——中间的感叹号

74. 直接使用 `Random` 对象的 `nextInt` 或者 `nextLong` 方法

75. 如果想获取更加精确的纳秒级时间值， 使用 `System.nanoTime()` 的方式。在 `JDK8` 中，针对统计时间等场景，推荐使用 `Instant` 类

76. 好的单元测试必须遵守 `AIR` 原则
```
    A： Automatic（自动化）
    I： Independent（独立性）
    R： Repeatable（可重复）
```
77. 编写单元测试代码遵守 `BCDE` 原则，以保证被测试模块的交付质量。
```
    B： Border，边界值测试，包括循环边界、特殊取值、 特殊时间点、数据顺序等。
    C： Correct，正确的输入，并得到预期的结果。
    D： Design，与设计文档相结合，来编写单元测试。
    E： Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。
```
78. 隶属于用户个人的页面或者功能必须进行权限控制校验

79. 用户敏感数据禁止直接展示，必须对展示数据进行脱敏

80. 用户输入的 `SQL` 参数严格使用参数绑定或者 `METADATA` 字段值限定，防止 `SQL` 注入，禁止字符串拼接 `SQL` 访问数据库

81. 用户请求传入的任何参数必须做有效性验证

82. 表单、 `AJAX` 提交必须执行 `CSRF` 安全过滤

83. 在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷导致资损

84. `MySQL` 在 `Windows` 下不区分大小写，但在 `Linux `下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝

85. 小数类型为 `decimal`，禁止使用 `float` 和 `double`

86. 表必备三字段： `id, gmt_create, gmt_modified`

87. 建组合索引的时候，区分度最高的在最左边

88. `count(*)`会统计值为 `NULL` 的行，而 `count(列名)` 不会统计此列为 `NULL` 值的行

89. 使用 `ISNULL()` 来判断是否为 `NULL` 值

90. `POJO` 类的布尔属性不能加 `is`，而数据库字段必须加 `is_`

91. `sql.xml` 配置参数使用：` #{}`，` #param#`； 不要使用 `${}` 此种方式容易出现` SQL` 注入

92. 所有 `pom` 文件中的依赖声明放在 `<dependencies>` 语句块中，所有版本仲裁放在 `<dependencyManagement>` 语句块中

93. 高并发服务器建议调小 `TCP` 协议的 `time_wait` 超时时间

94. 调大服务器所支持的最大文件句柄数（`File Descriptor`，简写为 `fd`），主流的 `linux` 服务器默认所支持最大 `fd` 数量为 `1024`

95. 给 `JVM `设置 `-XX:+HeapDumpOnOutOfMemoryError` 参数，让 `JVM` 碰到 `OOM` 场景时输出 `dump` 信息

96. 在线上生产环境， `JVM` 的 `Xms` 和 `Xmx` 设置一样大小的内存容量， 避免在 `GC` 后调整堆大小带来的压力

97. ` NPE（java.lang.NullPointerException）` : 空指针异常

98. `ORM（Object Relation Mapping）` : 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 `iBATIS`, `mybatis` 等框架

99. `GAV（GroupId、 ArtifactctId、 Version）` : `Maven` 坐标，是用来唯一标识 `jar` 包

100. 关键代码一定要 `try-catch`
