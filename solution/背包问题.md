```
    int max(int a, int b) {
        return a > b ? a : b;
    }
    //01背包
    void ZeroOnePack(int val, int vol, final int V, final int[] dp) {
        for (int v = V; v >= vol; v--) {
            dp[v] = max(dp[v], dp[v - vol] + val);
        }
    }
    //完全背包
    void CompletePack(int val, int vol, final int V, final int[] dp) {
        for (int v = vol; v <= V; v++) {
            dp[v] = max(dp[v], dp[v - vol] + val);
        }
    }
    //多重背包
    void MultiplePack(int val, int vol, int num, final int V, final int[] dp) {
        int cnt;
        if (vol * num >= V) {
            CompletePack(val, vol, V, dp);
        } else {
            cnt = 1;
            while (cnt < num) {
                ZeroOnePack(val * cnt, vol * cnt, V, dp);
                num -= cnt;
                cnt += cnt;
            }
            ZeroOnePack(val * num, vol * num, V, dp);
        }
    }

    //分组背包
    void GroupPack(int[][] weight, int[][] value, int[] count, final int V,
            final int[] dp) {
        // 从第 0 组到 n-1 组
        for (int i = 0; i < count.length; i++) {
            // 与01背包类似，容量递减
            for (int k = V; k >= 0; k--) {
                // count[i] 表示第 i 组的个数，j 表示 i组中的第几个
                for (int j = 0; j < count[i]; j++) {
                    if (k >= weight[i][j]) {
                        dp[k] = max(dp[k], value[i][j] + dp[k - weight[i][j]]);
                    }
                }
            }
        }
    }
```

### 01 背包

有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大。

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

用子问题定义状态：即 f[i][v]表示前 i 件物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是：

```
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
```

01 背包问题的伪代码就可以这样写：

```
for i=1..N
ZeroOnePack(c[i],w[i]);
```

### 完全背包

有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。第 i 种物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

这个问题非常类似于 01 背包问题，所不同的是每种物品有无限件。

如果仍然按照解 01 背包时的思路，令 f[i][v]表示前 i 种物品恰放入一个容量为 v 的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：

```
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}
```

### 多重背包

有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 n[i]件可用，每件费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

每件物品的个数为 n[i]个

基本的方程只需将完全背包问题的方程略微一改即可，因为对于第 i 种物品有 n[i]+1 种策略：取 0 件，取 1 件……取 n[i]件。

令 f[i][v]表示前 i 种物品恰放入一个容量为 v 的背包的最大权值，则有状态转移方程：

```
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}
```

### 混合背包

以上三种背包的混合，有的物品只能取一次，有的物品能取无限次，有的物品能取有限次

```
for i=1..N
if 第 i 件物品是 01 背包
ZeroOnePack(c[i],w[i])
else if 第 i 件物品是完全背包
CompletePack(c[i],w[i])
else if 第 i 件物品是多重背包
MultiplePack(c[i],w[i],n[i])
```

### 分组背包

有 n 件物品，分为若干组，每组中只能选择一件物品，问可以得到的最大价值

### 二维费用的背包问题

二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价 1 和代价 2，第 i 件物品所需的两种代价分别为 a[i]和 b[i]。两种代价可付出的最大值（两种背包容量）分别为 V 和 U。物品的价值为 w[i]。

费用加了一维，只需状态也加一维即可。设 f[i][v][u]表示前 i 件物品付出两种代价分别为 v 和 u 时可获得的最大价值。状态转移方程就是：

```
f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}
```

如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量 v 和 u 采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。这里就不再给出伪代码了，相信有了前面的基础，你能够自己实现出这个问题的程序。

有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 M 件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以付出的最大件数费用为 M。换句话说，设 f[v][m]表示付出费用 v、最多选 m 件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在 f[0..V][0..m]范围内寻找答案。

### 初始化时要注意

（1）如果要求恰好装满背包，那么在初始化时除了 dp[0]为 0 其它 dp[1..V]均设为-∞（求的是最大解，如果求的是最小解，则为 ∞）

（2）如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将 dp[0..V]全部设为 0

### 输出方案

一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。

### 求方案总数

对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。

对于这类改变问法的问题，一般只需将状态转移方程中的 max 改成 sum 即可。例如若每件物品均是完全背包中的物品，转移方程即为

```
f[i][v]=sum{f[i-1][v],f[i][v-c[i]]}
```

初始条件 f[0][0]=1。

事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

### 最优方案的总数

这里的最优方案是指物品总价值最大的方案。以 01 背包为例。

结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求 f[i][v]的同时求 g[i][v]的伪代码如下：

```
for i=1..N
    for v=0..V
        f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
        g[i][v]=0
        if(f[i][v]==f[i-1][v])
            inc(g[i][v],g[i-1][v])
        if(f[i][v]==f[i-1][v-c[i]]+w[i])
            inc(g[i][v],g[i-1][v-c[i]])
```

如果你是第一次看到这样的问题，请仔细体会上面的伪代码。

### 求次优解、第 K 优解

对于求次优解、第 K 优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第 K 优解则比求最优解的复杂度上多一个系数 K。

其基本思想是将每个状态都表示成有序队列，将状态转移方程中的 max/min 转化成有序队列的合并。

这里仍然以 01 背包为例讲解一下。
首先看 01 背包求最优解的状态转移方程：f[i][v]=max{f[i-1][v],f[i-1]v-c[i]]+w[i]}。如果要求第 K 优解，那么状态 f[i][v]就应该是一个大小为 K 的数组 f[i][v][1..K]。其中 f[i][v][k]表示前 i 个物品、背包大小为 v 时，第 k 优解的值。“f[i][v]是一个大小为 K 的数组”这一句，熟悉 C 语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然 f[i][v][1..K]这 K 个数是由大到小排列的，所以我们把它认为是一个有序队列。

然后原方程就可以解释为：f[i][v]这个有序队列是由 f[i-1][v]和 f[i-1]v-c[i]]+w[i]这两个有序队列合并得到的。有序队列 f[i-1][v]即 f[i-1][v][1..K]，f[i-1]v-c[i]]+w[i]则理解为在 f[i-1]v-c[i]][1..K]的每个数上加上 w[i]后得到的有序队列。合并这两个有序队列并将结果（的前 K 项）储存到 f[i][v][1..K]中的复杂度是 O(K)。最后的答案是 f[N][v][K]。总的复杂度是 O(NVK)。

为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为 K 的数组，并在这个数组中有序的保存该状态可取到的前 K 个最优值。那么，对于任两个状态的 max 运算等价于两个由大到小的有序队列的合并。

另外还要注意题目对于“第 K 优解”的定义，将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。
