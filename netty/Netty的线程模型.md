### Netty 的线程模型是什么样的？

https://www.cnblogs.com/luoxn28/p/11875340.html

### IO 模型

BIO：同步阻塞 IO 模型；
NIO：基于 IO 多路复用技术的“非阻塞同步”IO 模型。简单来说，内核将可读可写事件通知应用，由应用主动发起读写操作；
AIO：非阻塞异步 IO 模型。简单来说，内核将读完成事件通知应用，读操作由内核完成，应用只需操作数据即可；应用做异步写操作时立即返回，内核会进行写操作排队并执行写操作。
NIO 和 AIO 不同之处在于应用是否进行真正的读写操作。

### reactor 和 proactor 模型

reactor：基于 NIO 技术，可读可写时通知应用；
proactor：基于 AIO 技术，读完成时通知应用，写操作应用通知内核。

### netty 的线程模型是基于 Reactor 模型的。

Reactor 模式是基于事件驱动开发的，核心组成部分包括 Reactor 和线程池，其中 Reactor 负责监听和分配事件，线程池负责处理事件，而根据 Reactor 的数量和线程池的数量，又将 Reactor 分为三种模型:

（1）单线程模型 (单 Reactor 单线程)：是指所有的 I/O 操作都在同一个 NIO 线程上面完成的，此时 NIO 线程职责包括：接收新建连接请求、读写操作等。

注意，Redis 的请求处理也是单线程模型，为什么 Redis 的性能会如此之高呢？因为 Redis 的读写操作基本都是内存操作，并且 Redis 协议比较简洁，序列化/反序列化耗费性能更低

（2）多线程模型 (单 Reactor 多线程)：Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程来处理连接读写操作，一个 NIO 线程处理 Accept。一个 NIO 线程可以处理多个连接事件，一个连接的事件只能属于一个 NIO 线程。

可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程的模型性能更优

（3）主从多线程模型 (多 Reactor 多线程)：服务端用于接收客户端连接的不再是一个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求并处理完成后（可能包含接入认证等），将新创建的 SocketChannel 注册到 I/O 线程池（subreactor 线程池）的某个 I/O 线程上， 由它负责 SocketChannel 的读写和编解码工作。

虽然 bossGroup 也能指定多个 NioEventLoop（一个 NioEventLoop 对应一个线程），但是默认情况下只会有一个线程，因为一般情况下应用程序只会使用一个对外监听端口

现代 linux 中，多个 socker 同时监听同一个端口也是可行的，nginx 1.9.1 也支持这一行为。linux 3.9 以上内核支持 SO_REUSEPORT 选项，允许多个 socker bind/listen 在同一端口上。这样，多个进程可以各自申请 socker 监听同一端口，当连接事件来临时，内核做负载均衡，唤醒监听的其中一个进程来处理，reuseport 机制有效的解决了 epoll 惊群问题

再回到刚才提出的问题，java 中多线程来监听同一个对外端口，epoll 方法是线程安全的，这样就可以使用使用多线程监听 epoll_wait 了么？

当然是不建议这样干的，除了 epoll 的惊群问题之外，还有一个就是，一般开发中我们使用 epoll 设置的是 LT 模式（水平触发方式，与之相对的是 ET 默认，前者只要连接事件未被处理就会在 epoll_wait 时始终触发，后者只会在真正有事件来时在 epoll_wait 触发一次），这样的话，多线程 epoll_wait 时就会导致第一个线程 epoll_wait 之后还未处理完毕已发生的事件时，第二个线程也会 epoll_wait 返回，显然这不是我们想要的（多个线程处理同一个，有并发问题）

第一是完成 TCP 三次握手的套接字应该注册到 worker 线程池中的哪一个 NioEventLoop 的 Selector 上，第二个是 NioEventLoop 中的线程负责监听注册到 Selector 上的所有连接的读写事件和处理队列里面的消息，那么会不会导致由于处理队列里面任务耗时太长导致来不及处理连接的读写事件？

对于第一个问题 NioEventLoop 的分配，Netty 默认使用的是 PowerOfTwoEventExecutorChooser，是采用的轮询取模方式来进行分配。
对于第二个问题，Netty 默认是采用时间均分策略来避免某一方处于饥饿状态:
