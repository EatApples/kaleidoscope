```
趣谈 Linux 操作系统
像故事一样的操作系统入门课
刘超 前网易杭州研究院云计算技术部首席架构师
```

### 1. 那这个进程如何关闭呢？

我们假设启动的程序包含某个关键字，那就可以使用下面的命令。

```s
ps -ef |grep 关键字 |awk '{print $2}'|xargs kill -9
```

### 2. fork

当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。

对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。

有个系统调用 waitpid，父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

### 3. x86

x86 作为一个开放的营商环境，有两种模式，一种模式是实模式，只能寻址 1M，每个段最多 64K。

另一种是保护模式，对于 32 位系统，能够寻址 4G

### 4. 0 号进程

在操作系统里面，先要有个创始进程，有一行指令 set_task_stack_end_magic(&init_task)。这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 0 号进程。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是进程列表的第一个。

rest_init 的第一大工作是，用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程，这个是 1 号进程。rest_init 的第一个大事情才完成。我们仅仅形成了用户态所有进程的祖先。

那内核态的进程有没有一个人统一管起来呢？有的，rest_init 第二大事情就是第三个进程，就是 2 号进程。

PID 1 的进程就是我们的 init 进程 systemd，PID 2 的进程是内核线程 kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。

### 5. ELF

在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 ELF（Executeable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。

在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件，这就是 ELF 的第一种类型，可重定位文件（Relocatable File）。

形成的二进制文件叫可执行文件，是 ELF 的第二种格式。

动态链接库，就是 ELF 的第三种类型，共享对象文件（Shared Object）。

### 6.
