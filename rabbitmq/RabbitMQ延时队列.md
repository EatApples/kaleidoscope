由于 RabbitMQ 本身不支持延时队列（延时消息），所以要通过其他方式来实现。总的来说有三种：

1，先存储到数据库，用定时任务扫描，登记时刻+延时时间，就是需要投递的时刻（与 RabbitMQ 无关）

2， 利用 RabbitMQ 的死信队列（Dead Letter Queue）实现（大多数情况）

3， 利用 rabbitmq-delayed-message-exchange 插件（3.5.7以上版本才有）

这里考虑使用 RabbitMQ 本身的特性，提出了以下 3 种延迟队列的实现方式：

### 方案一：延迟模式
概要：发送端的消息体里设置延迟时间；消费端收到后放入本地延迟队列（DelayQueue），然后异步从本地延迟队列中消费，处理完后 ACK

影响：发送接收的逻辑需要封装，适配

优势：与 RabbitMQ 无关，通用；功能前后兼容（没有延迟逻辑可认为延迟时间为0）；

劣势：最终延迟时间可能与预期不符（因为 RabbitMQ 队列中的消息有先后，可能延迟时间短的消息由于靠后而延迟处理，造成延迟增加）

开发难度：简单；需要封装收发代码；消费端的处理逻辑需要变动；

### 方案二：过期模式
x-message-ttl：消息过期时间（Time To Live，TTL），超过过期时间之后即变为死信（Dead-letter），不会再被消费者消费。

设置TTL有两种方式：

（1）创建队列时指定x-message-ttl，此时整个队列具有统一过期时间；

（2）发送消息为每个消息设置expiration，此时消息之间过期时间不同。

注意：如果两者都设置，过期时间取两者最小。

流程：生产者——原交换机——原队列——（超过TTL之后）——死信交换机——死信队列——最终消费者

缺点：
（1）如果统一用队列来设置消息的TTL，当梯度非常多的情况下，比如1分钟，2分钟，5分钟，10分钟，20分钟，30分钟……需要创建很多交换机和队列来路由消息

（2）如果单独设置消息的TTL，则可能会造成队列中的消息阻塞——前一条消息没有出队（没有被消费），后面的消息无法投递

（3）可能存在一定的时间误差

### 方案三：死亡模式

这里采用一种中庸的方式。

概要：发送端的消息发送到临时队列，一条消息就创建一个临时队列。临时队列设置队列存活时间（x-expires）与消息过期时间（x-message-ttl）。消息过期时间必须小于队列存活时间，因为队列消失，队列中的消息并不会成为死信。还要设置死信交换机（x-dead-letter-exchange，设置为 topic 类型）与死信路由键（x-dead-letter-routing-key，设置为目的队列名）。临时队列中的消息过期后，最终通过死信交换机路由到目的队列。之后该临时队列由于存活时间到自动消失。

优势：消息之间互不影响；延迟时间可控

劣势：可能存在大量的临时队列

开发难度：一般；发送端需要建立中间的死信路由规则，接收端无需变动；

个人倾向于死亡模式。
