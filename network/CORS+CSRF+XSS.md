### 同源策略
出于浏览器的同源策略限制。同源策略(same origin policy)是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。

同源策略会阻止一个域的 javascript 脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）。

### 跨域
当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域。

### 非同源限制
（1）无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB

（2）无法接触非同源网页的 DOM

（3）无法向非同源地址发送 AJAX 请求

### CORS
CORS 是跨域资源分享(Cross-Origin Resource Sharing)的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

普通跨域请求：只需服务器端设置Access-Control-Allow-Origin

带cookie跨域请求：前后端都需要进行设置（前端设置：根据xhr.withCredentials字段判断。服务端设置：主要是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许ajax进行跨域的访问）

### CSRF
跨站请求伪造(Cross-site request forgery)，是一种对网站的恶意利用，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。

CSRF是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。CSRF跟XSS攻击一样，存在巨大的危害性。

你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。        

简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

对比XSS：跟跨网站脚本(XSS)相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

### CSRF攻击防御

（1）尽量使用POST，限制GET

（2）浏览器Cookie策略

Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。

另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。

（3）加验证码

验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。

（4）Referer Check

Referer Check 在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。

但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。

（5）Anti CSRF Token

现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。

例子：

1. 用户访问某个表单页面。

2. 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。

3. 在页面表单附带上Token参数。

4. 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。

这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。

注意：CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。

### CSRF漏洞检测
检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。

### CSRF总结
CSRF攻击是攻击者利用用户的身份操作用户帐户的一种攻击方式，通常使用Anti CSRF Token来防御CSRF攻击，同时要注意Token的保密性和随机性。

### XSS
全称：Cross Site Script(跨站脚本)，为了与层叠样式表css区分，将跨站脚本简写为XSS。

危害：盗取用户信息、钓鱼、制造蠕虫等。

黑客通过“HTML注入”篡改了网页，插入了恶意脚本，从而在用户在浏览网页时，实现控制用户浏览器行为的一种攻击方式。

黑客可以利用XSS盗取用户的cookie，有了用户的cookie，可以以用户的身份来正常访问站点。

XSS属于客户端代码注入，通常注入代码是JavaScript。区别于命令注入，SQL注入属于服务端代码注入。

### 实施XSS攻击需要具备两个条件：
（1）需要向web页面注入恶意代码；

（2）这些恶意代码能够被浏览器成功的执行

### XSS分类
第一、XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。

第二、XSS存储型攻击，恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上，但OA系统，和CRM系统上也能看到它身影，比如：某CRM系统的客户投诉功能上存在XSS存储型漏洞，黑客提交了恶意攻击代码，当系统管理员查看投诉信息时恶意代码执行，窃取了客户的资料，然而管理员毫不知情，这就是典型的XSS存储型攻击。

### 资料来源
#### 1. 什么是跨域？跨域解决方法
https://blog.csdn.net/qq_38128179/article/details/84956552
#### 2. CSRF攻击与防御
https://blog.csdn.net/freeking101/article/details/86537087
#### 3. 浅谈XSS攻击原理与解决方法
https://www.cnblogs.com/shawWey/p/8480452.html
#### 4. 【干货分享】XSS攻击进阶篇——那些年我们看不懂的XSS
http://blog.nsfocus.net/xss-advance/
