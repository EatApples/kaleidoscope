# 注册

### 注册中心的原理

首先，服务注册的功能体现在：

- 服务实例启动时注册到服务注册表、关闭时则注销（服务注册）。
- 服务消费者可以通过查询服务注册表来获得可用的实例（服务发现）。
- 服务注册中心需要调用服务实例的健康检查 API 来验证其是否可以正确的处理请求（健康检查）。

### ephemeral

实现数据一致性监听，ephemeral 标识服务是否为临时服务，默认是持久化的，也就是 true

true 表示采用 raft 协议，

false 表示采用 Distro

### Nacos 集群选举

Nacos 集群采用 Raft 算法实现。它是一种比较简单的选举算法，用于选举出 Nacos 集群中最重要的 Leader（领导）节点。

在集群中选举出 Leader 是最重要的工作，产生选举的时机有三个：

- 在 Nacos 节点启动后，还没有产生 Leader 时选举；

- 集群成员总量变更时重新选举；

- 当 Leader 停止服务后重新选举；

### Nacos 节点间的数据同步过程

在 Raft 算法中，只有 Leader 才拥有数据处理与信息分发的权利。因此当微服务启动时，假如注册中心指定为 Follower 节点，则步骤如下：

第一步，Follower 会自动将注册心跳包转给 Leader 节点；

第二步，Leader 节点完成实质的注册登记工作；

第三步，完成注册后向其他 Follower 节点发起“同步注册日志”的指令；

第四步，所有可用的 Follower 在收到指令后进行“ack 应答”，通知 Leader 消息已收到；

第五步，当 Leader 接收过半数 Follower 节点的 “ack 应答”后，返回给微服务“注册成功”的响应信息。

此外，对于其他无效的 Follower 节点，Leader 仍会不断重新发送，直到所有 Follower 的状态与 Leader 保持同步。

# 配置

### Nacos 配置更新原理

Nacos 服务端创建了相关的配置项后，客户端就可以进行监听了。客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象中，然后会重新计算 CacheData 的 md5 属性的值，此时就会对该 CacheData 所绑定的 Listener 触发 receiveConfigInfo 回调。

考虑到服务端故障的问题，客户端将最新数据获取后会保存在本地的 snapshot 文件中，以后会优先从文件中获取配置信息的值。

### 那么客户端如何感知到数据发生变化的呢？

Nacos 的客户端维护了一个长轮询的任务，去检查服务端的配置信息是否发生变更，如果发生了变更，那么客户端会拿到变更的 groupKey 再根据 groupKey 去获取配置项的最新值即可。

每次都靠客户端去发请求，询问服务端我所关注的配置项有没有发生变更，那请求的间隔改设置为多少才合适呢？

如果间隔时间设置的太长的话有可能无法及时获取服务端的变更，如果间隔时间设置的太短的话，那么频繁的请求对于服务端来说无疑也是一种负担。

所以最好的方式是客户端每隔一段长度适中的时间去服务端请求，而在这期间如果配置发生变更，服务端能够主动将变更后的结果推送给客户端，这样既能保证客户端能够实时感知到配置的变化，也降低了服务端的压力。

### 长轮训的概念

客户端发起一个请求到服务端，服务端收到客户端的请求后，并不会立刻响应给客户端，而是先把这个请求 hold 住，然后服务端会在 hold 住的这段时间检查数据是否有更新，如果有，则响应给客户端，如果一直没有数据变更，则达到一定的时间（长轮训时间间隔）才返回。

长轮训典型的场景有： 扫码登录、扫码支付。

### nacos 是采用推还是拉

实时感知是建立在客户端拉和服务端“推”的基础上，但是这里的服务端“推”需要打上引号，因为服务端和客户端直接本质上还是通过 http 进行数据通讯的，之所以有“推”的感觉，是因为服务端主动将变更后的数据通过 http 的 response 对象提前写入了

### 客户端长轮询的响应时间会受什么影响

客户端长轮询的响应时间，设置的是 30s，但是有时响应很快，有时响应很慢，这取决于服务端的配置有没有发生变化。当配置发生变化时，响应很快就会返回，当配置一直没有发生变化时，会等到 29.5s 之后再进行响应。

### 为什么更改了配置信息后客户端会立即得到响应

因为服务端会在更改了配置信息后，找到具体的客户端请求中的 response，然后直接将结果写入 response 中，就像服务端对客户端进行的数据 “推送” 一样，所以客户端会很快得到响应。

### 客户端的超时时间为什么要设置为 30s

这应该是一个经验值，该超时时间关系到服务端调度任务的等待时间，服务端在前 29.5s 只需要进行等待，最后的 0.5s 才进行配置变更检查。

如果设置的太短，那服务端等待的时间就太短，如果这时配置变更的比较频繁，那很可能无法在等待期对客户端做推送，而是滑动到检查期对数据进行检查后才能将数据变更发回给客户端，检查期相比等待期需要进行数据的检查，涉及到 IO 操作，而 IO 操作是比较昂贵的，我们应该尽量在等待期就将数据变更发送给客户端。

http 请求本来就是无状态的，所以没必要也不能将超时时间设置的太长，这样是对资源的一种浪费。

# 资料

### 1. Nacos 注册中心的设计原理详解

https://www.infoq.cn/article/B*6vyMIKao9vAKIsJYpE

### 2. 重磅官宣：Nacos2.0 发布，性能提升 10 倍

https://mp.weixin.qq.com/s/dBVo6w0sjUORd6Axpj3zTg

### 3. Nacos 配置中心原理分析

https://www.cnblogs.com/wuzhenzhao/p/11385079.html

### 4. Nacos 服务注册的原理

https://www.cnblogs.com/wuzhenzhao/p/13625491.html

### 5. SpringCloud-Nacos 注册中心实现原理

https://blog.csdn.net/Zong_0915/article/details/113001226

### 6. SpringCloud-Nacos 配置中心实现原理

https://blog.csdn.net/Zong_0915/article/details/113089265

### 7. nacos 系列

https://segmentfault.com/a/1190000038835575?utm_source=sf-similar-article
https://www.iocoder.cn/Nacos/good-collection/

### 8. 全网最详细 nacos 源码剖析-出自图灵学院微服务源码课 Nacos 源码剖析-服务注册与发现(临时实例 AP 模式)

https://www.processon.com/view/5e25b762e4b04579e409e81f?fromnew=1
https://www.processon.com/view/5e5fa095e4b03ecc75201629?fromnew=1
https://www.processon.com/view/5e60a8f5e4b03ecc7521bc59?fromnew=1

# PPT

注册与配置
AP 和 CP
RAFT 和 DISTRO
ABA 问题
HTTP 与 GRPC
