### 1. XXL 的架构

（1）获取到 MySQL 锁的调度中心从 MySQL 获取未来 5 秒内的任务，并将任务加入到对应秒的时间轮槽里，然后更新任务的下次执行时间写入 MySQL。例如当前时间是 12:35，那么会加载 12:40 之前要运行的任务；若任务 A 要在 12:37 调度，那么会把 A 加入到 37 这一秒对应的时间轮槽里；

（2）调度中心会有个专门线程每秒扫描时间轮，获取当前秒要执行的任务集合，并提交到线程池里。这里，线程池拆分为快、慢两个线程池，1 分钟窗口期内任务耗时达 500ms 超过 10 次，该窗口期内判定为慢任务，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性；

（3）线程池的工作线程向 MySQL 插入一条调度日志，并根据任务路由策略从服务的执行器列表中选择一个执行器(分片广播任务会选择所有执行器)，然后将任务调度信息发送至目标执行器。调度信息主要包括调度日志 ID、jobId、job 名称、阻塞策略、超时时间、参数等；

（4）执行器收到调度信息后，将调度信息加入到对应任务处理线程的等待队列中；任务处理程序串行从队列中取调度信息进行任务的执行，执行完后将结果写入一个公共的结果队列中。这里，每个任务有一个单独的处理线程和一个等待队列，调度信息放入队列，任务处理线程从队列里取调度信息进行执行，以此实现解耦；

（5）执行器有一个专门的回调线程定时批量从结果队列里获取任务结果，并回调告知调度中心；

（6）调度中心收到回调结果后，将结果更新至调度日志表中。如果任务失败，在此处可以进行重试。
————————————————
版权声明：本文为 CSDN 博主「weixin_39628247」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39628247/article/details/112477990
