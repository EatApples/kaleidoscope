### 1. 重排序
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
+ （1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

+ （2）指令级并行的重排序。现代处理器采用了指令级并行技术（`Instruction-Level Parallelism`， `ILP`）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

+ （3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

在`JMM`中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在`happens-before`关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

### 2. 与程序员密切相关的`happens-before`规则如下：
+ （1）程序顺序规则：一个线程中的每个操作，`happens-before` 于该线程中的任意后续操作。

+ （2）监视器锁规则：对一个监视器锁的解锁，`happens-before` 于随后对这个监视器锁的加锁。

+ （3）`volatile`变量规则：对一个 `volatile` 域的写，`happens-before` 于任意后续对这个 `volatile` 域的读。

+ （4）传递性：如果A `happens-before` B，且 B `happens-before` C，那么A `happens-before` C。

注意，两个操作之间具有 `happens-before` 关系，并不意味着前一个操作必须要在后一个操作之前执行！`happens-before`仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（`the first is visible to and ordered before the second`）

### 3. `as-if-serial`语义
`as-if-serial`语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，`runtime` 和处理器都必须遵守`as-if-serial`语义。

`as-if-serial`语义把单线程程序保护了起来，遵守`as-if-serial`语义的编译器，`runtime` 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。`as-if-serial`语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。

编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是`as-if-serial`语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

`JMM`在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。

### 4. 对于未同步或未正确同步的多线程程序，`JMM`只提供最小安全性：

线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（`0`，`null`，`false`），`JMM`保证线程读操作读取到的值不会无中生有（`out of thin air`）的冒出来。

为了实现最小安全性，`JVM`在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（`JVM`内部会同步这两个操作）。因此，在以清零的内存空间（`pre-zeroed memory`）分配对象时，域的默认初始化已经完成了。

和顺序一致性模型一样，未同步程序在`JMM`中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异：

+ （1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而`JMM`不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。

+ （2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而`JMM`不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。

+ （3）`JMM`不保证对`64`位的`long`型和`double`型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。

注意，在`JSR-133`之前的旧内存模型中，一个`64`位`long`/ `double`型变量的读/写操作可以被拆分为两个`32`位的读/写操作来执行。从`JSR-133`内存模型开始（即从`JDK5`开始），仅仅只允许把一个`64`位`long`/`double`型变量的写操作拆分为两个`32`位的写操作来执行，任意的读操作在`JSR-133`中都必须具有原子性（即任意读操作必须要在单个读事务中执行）

### 5. `volatile`变量自身具有下列特性：
+ 可见性。对一个`volatile`变量的读，总是能看到（任意线程）对这个`volatile`变量最后的写入。

+ 原子性：对任意单个`volatile`变量的读/写具有原子性，但类似于`volatile++`这种复合操作不具有原子性。

`JSR-133`开始，`volatile`变量的写-读可以实现线程之间的通信。

从内存语义的角度来说，`volatile`与锁有相同的效果：`volatile`写和锁的释放有相同的内存语义；`volatile`读与锁的获取有相同的内存语义。

下面对`volatile`写和`volatile`读的内存语义做个总结：

+ 线程A写一个`volatile`变量，实质上是线程A向接下来将要读这个`volatile`变量的某个线程发出了（其对共享变量所在修改的）消息。

+ 线程B读一个`volatile`变量，实质上是线程B接收了之前某个线程发出的（在写这个`volatile`变量之前对共享变量所做修改的）消息。

+ 线程A写一个`volatile`变量，随后线程B读这个`volatile`变量，这个过程实质上是线程A通过主内存向线程B发送消息。

### 6. 下面是`JMM`针对编译器制定的`volatile`重排序规则表：

+ 当第二个操作是`volatile`写时，不管第一个操作是什么，都不能重排序。这个规则确保`volatile`写之前的操作不会被编译器重排序到`volatile`写之后。

+ 当第一个操作是`volatile`读时，不管第二个操作是什么，都不能重排序。这个规则确保`volatile`读之后的操作不会被编译器重排序到`volatile`读之前。

+ 当第一个操作是`volatile`写，第二个操作是`volatile`读时，不能重排序。

`JMM`采取保守策略。下面是基于保守策略的`JMM`内存屏障插入策略：

+ 在每个`volatile`写操作的前面插入一个`StoreStore`屏障。

+ 在每个`volatile`写操作的后面插入一个`StoreLoad`屏障。

+ 在每个`volatile`读操作的后面插入一个`LoadLoad`屏障。

+ 在每个`volatile`读操作的后面插入一个`LoadStore`屏障。


与前面介绍的锁和`volatile`相比较，对`final`域的读和写更像是普通的变量访问。对于`final`域，编译器和处理器要遵守两个重排序规则：

+ （1）在构造函数内对一个`final`域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。

+ （2）初次读一个包含`final`域的对象的引用，与随后初次读这个`final`域，这两个操作之间不能重排序。

写`final`域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的`final`域已经被正确初始化过了，而普通域不具有这个保障。


### 7. `JMM`的内存可见性保证

`Java`程序的内存可见性保证按程序类型可以分为下列三类：

+ （1）单线程程序。单线程程序不会出现内存可见性问题。编译器，`runtime`和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。

+ （2）正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是`JMM`关注的重点，`JMM`通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。

+ （3）未同步/未正确同步的多线程程序。`JMM`为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（`0`，`null`，`false`）。

### 8. `JSR-133`对旧内存模型的修补
`JSR-133`对`JDK5`之前的旧内存模型的修补主要有两个：

+ （1）增强`volatile`的内存语义。旧内存模型允许`volatile`变量与普通变量重排序。`JSR-133`严格限制`volatile`变量与普通变量的重排序，使`volatile`的写-读和锁的释放-获取具有相同的内存语义。

+ （2）增强`final`的内存语义。在旧内存模型中，多次读取同一个`final`变量的值可能会不相同。为此，`JSR-133`为`final`增加了两个重排序规则。现在，`final`具有了初始化安全性。

### 扩展阅读
### 1. 《深入理解 Java 内存模型》读书笔记
http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/
