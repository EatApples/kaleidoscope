# Java 虚拟机规范

```
（Java SE 7 版）
原文版本. 2011/07/28
译文版本. 2011/11/13

作者：
Tim Lindholm、Frank Yellin
Gilad Bracha、Alex Buckley

译者：
周志明（icyfenix@gmail.com）
吴璞渊（wupuyuan@gmail.com）
冶秀刚（dennyy99@gmail.com）
```

### 1. Java 虚拟机

Java 虚拟机可以看作是一台抽象的计算机。如同真实的计算机那样，它有自己的指令集以及各种运行时内存区域。

Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式——Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。

### 2. Class 文件格式

编译后被 Java 虚拟机所执行的代码使用了一种平台中立（不依赖于特定硬件及操作系统的）的二进制格式来表示，并且经常（但并非绝对）以文件的形式存储，因此这种格式被称为 Class 文件格式。

Class 文件格式中精确地定义了类与接口的表示形式，包括在平台相关的目标文件格式中一些细节上的惯例，例如字节序（Byte Ordering）等。

### 3. 数据类型

与 Java 程序语言中的数据类型相似，Java 虚拟机可以操作的数据类型可分为两类：原始类型（Primitive Types，也经常翻译为原生类型或者基本类型）和引用类型（Reference Types）。

与之对应，也存在有原始值（Primitive Values）和引用值（Reference Values）两种类型的数值可用于变量赋值、参数传递、方法返回和运算操作。

Java 虚拟机希望尽可能多的类型检查能在程序运行之前完成，换句话说，编译器应当在编译期间尽最大努力完成可能的类型检查，使得虚拟机在运行期间无需进行这些操作。

### 4. 引用类型与值

Java 虚拟机中有三种引用类型：类类型（Class Types）、数组类型（Array Types）和接口类型（Interface Types）。这些引用类型的值分别由类实例、数组实例和实现了某个接口的类实例或数组实例动态创建。

其中，数组类型还包含一个单一维度（即长度不由其类型决定）的组件类型（Component Type），一个数组的组件类型也可以是数组。但从任意一个数组开始，如果发现其组件类型也是数组类型的话，继续重复取这个数组的组件类型，这样操作不断执行，最终一定可以遇到组件类型不是数组的情况，这时就把这种类型成为数组类型的元素类型（Element Type）。数组的元素类型必须是原始类型、类类型或者接口类型之中的一种。

在引用类型的值中还有一个特殊的值：null，当一个引用不指向任何对象的时候，它的值就用 null 来表示。一个为 null 的引用，在没有上下文的情况下不具备任何实际的类型，但是有具体上下文时它可转型为任意的引用类型。引用类型的默认值就是 null。

### 5. 方法区

在 Java 虚拟机中，方法区（Method Area）是可供各条线程共享的运行时内存区域。

方法区与传统语言中的编译代码储存区（Storage Area Of Compiled Code）或者操作系统进程的正文段（Text Segment）的作用非常类似，它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。

### 6. 运行时常量池

每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。

### 7. 本地方法栈

Java 虚拟机实现可能会使用到传统的栈（通常称之为“C Stacks”）来支持 native 方法（指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（Native MethodStack）。

当 Java 虚拟机使用其他语言（例如 C 语言）来实现指令集解释器时，也会使用到本地方法栈。

### 8. 栈帧

栈帧（Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。

栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。

栈帧的存储空间分配在 Java 虚拟机栈之中，每一个栈帧都有自己的局部变量表（Local Variables）、操作数栈（Operand Stack）和指向当前方法所属的类的运行时常量池的引用。

栈帧是线程本地私有的数据，不可能在一个栈帧之中引用另外一条线程的栈帧。

### 9. 局部变量表

栈帧中局部变量表的长度由编译期决定，并且存储于类和接口的二进制表示之中，既通过方法的 Code 属性保存及提供给栈帧使用。

一个局部变量可以保存一个类型为 boolean、byte、char、short、float、reference 和 returnAddress 的数据，两个局部变量可以保存一个类型为 long 和 double 的数据。

局部变量使用索引来进行定位访问，第一个局部变量的索引值为零，局部变量的索引值是从零至小于局部变量表最大容量的所有整数。

特别地，当一个实例方法被调用的时候，第 0 个局部变量一定是用来存储被调用的实例方法所在的对象的引用（即 Java 语言中的“this”关键字）。

### 10. 操作数栈

每一个栈帧（§2.6）内部都包含一个称为操作数栈（Operand Stack）的后进先出（Last-In-First-Out，LIFO）栈。栈帧中操作数栈的长度由编译期决定，并且存储于类和接口的二进制表示之中，既通过方法的 Code 属性保存及提供给栈帧使用。

每一个操作数栈的成员（Entry）可以保存一个 Java 虚拟机中定义的任意数据类型的值，包括 long 和 double 类型。

在任意时刻，操作数栈都会有一个确定的栈深度，一个 long 或者 double 类型的数据会占用两个单位的栈深度，其他数据类型则会占用一个单位深度。

### 11. 动态链接

每一个栈帧内部都包含一个指向运行时常量池的引用来支持当前方法的代码实现动态链接（Dynamic Linking）。

在 Class 文件里面，描述一个方法调用了其他方法，或者访问其成员变量是通过符号引用（Symbolic Reference）来表示的，动态链接的作用就是将这些符号引用所表示的方法转换为实际方法的直接引用。

类加载的过程中将要解析掉尚未被解析的符号引用，并且将变量访问转化为访问这些变量的存储结构所在的运行时内存位置的正确偏移量。

### 12. 初始化方法的特殊命名

在 Java 虚拟机层面上，Java 语言中的构造函数在《Java 语言规范 （第三版）》 是以一个名为<init>的特殊实例初始化方法的形式出现的，<init>这个方法名称是由编译器命名的，因为它并非一个合法的 Java 方法名字，不可能通过程序编码的方式实现。

实例初始化方法只能在实例的初始化期间，通过 Java 虚拟机的 invokespecial 指令来调用，只有在实例正在构造的时候，实例初始化方法才可以被调用访问。

一个类或者接口最多可以包含不超过一个类或接口的初始化方法，类或者接口就是通过这个方法完成初始化的。这个方法是一个不包含参数的静态方法，名为<clinit>。这个名字也是由编译器命名的，因为它并非一个合法的 Java 方法名字，不可能通过程序编码的方式实现。

类或接口的初始化方法由 Java 虚拟机自身隐式调用，没有任何虚拟机字节码指令可以调用这个方法，只有在类的初始化阶段中会被虚拟机自身调用。

### 13. 异常

Java 虚拟机里面的异常使用 Throwable 或其子类的实例来表示，抛异常的本质实际上是程序控制权的一种即时的、非局部（Nonlocal）的转换——从异常抛出的地方转换至处理异常的地方。

由 Java 虚拟机执行的每一个方法都会配有零至多个异常处理器（Exception Handlers），异常处理器描述了其在方法代码中的有效作用范围（通过字节码偏移量范围来描述）、能处理的异常类型以及处理异常的代码所在的位置。

搜索异常处理器时的搜索顺序是很关键的，在 Class 文件里面，每个方法的异常处理器都存储在一个表中。在运行时，当有异常出现之后，Java 虚拟机就按照 Class 文件中的异常处理器表描述异常处理器的先后顺序，从前至后进行搜索。

### 14. 指令

Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（Opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（Operands）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。

### 15. 加载和存储指令

载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传输。

### 16. 运算指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上运算指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是那种算术指令，都是使用 Java 虚拟机的数字类型的。

### 17. 类型转换指令

类型转换指令可以将两种 Java 虚拟机数值类型进行相互转换，这些转换操作一般用于实现用户代码的显式类型转换操作，或者用来处理 Java 虚拟机字节码指令集中指令非完全独立独立的问题。

### 18. 同步

Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的同步。

方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构（method_info Structure）中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有管程，然后再执行方法，最后再方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获得同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。

同步一段指令集序列通常是由 Java 语言中的 synchronized 块来表示的，Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义，正确实现 synchronized 关键字需要编译器与 Java 虚拟机两者协作支持。

### 19. 字段

每个字段（Field）都由 field_info 结构所定义，在同一个 Class 文件中，不会有两个字段同时具有相同的字段名和描述符。

### 20. 格式检查

如果 Java 虚拟机准备加载某个预期为 Class 文件格式的文件，它首先应保证这个文件符合 Class 文件格式的基本格式标准，这个过程就被称为格式检查。

格式检查需要确认 Class 文件的开头 4 个字节必须为正确的魔数，所有预定义的属性必须符合它们应有的长度，文件的尾部不能缺少或者多出额外的字节，常量池必须不含任何被规范未预定义的信息。

### 21. Java 虚拟机限制

下面为隐含在 Class 文件格式中的 Java 虚拟机限制：

（1）每个类或接口的常量池项最多为 65535 个，它是由 ClassFile 结构中的 16 位 constant_pool_count 字段的值决定。这限制了单个类或接口的复杂度。

（2）方法调用时创建的栈帧的局部变量表中的最大局部变量个数 65535 个，它是由方法代码所处的 Code 属性中的 max_locals 项的值和 Java 虚拟机指令集的 16 位局部变量索引所决定。注意，每个 long 和 double 类型都被认为会使用两个局部变量位置并占据 max_locals 中的两个单元，所以使用这些类型时，局部变量的限制的最大值就会相应地减少。

（3）类或接口中可以声明的字段数最多为 65535 个，它是由 ClassFile 结构中 fields_count 项的值所决定。注意，ClassFile 结构中的 fields_count 项的值不包含从父类或父接口中继承下来的字段。

（4）类或接口中可以声明的方法数最多为 65535 个，它是由 ClassFile 结构中的 methods_count 项的值所决定。注意，ClassFile 结构中的 methods_count 项的值不包含从父类或父接口中继承下来的方法。

（5）类或接口的直接父接口最多为 65535 个，它是由 ClassFile 结构中的 interfaces_count 项的值所决定。

（6）方法栈帧中的操作数栈的大小深度为 65535， 它是由 Code 属性的 max_stack 字段值来决定。需要注意的是每个 long 和 double 类型的数据被认为占用 max_locals 中的两个单元，所以使用这些类型时，操作数栈的限制的最大值就会相应地减少。

（7）数组的维度最大为 255 维，这由 multianewarray 指令的 dimensions 操作码及 multianewarray，anewarray 和 newarray 指令的约束来决定。

（8）方法的参数最多有 255 个，它是由方法描述符的定义所限制，如果方法调用是针对实例或接口方法，那么这个限制也包含着占有一个单元的 this。注意对于定义在方法描述符中的参数长度来说，每个 long 和 double 参数都会占用两个长度单位，所以如果有这些类型的话，最终的限制的最大值将会变小。

（9）字段和方法名称、字段和方法描述符以及其它常量字符串值（由 ConstantValue 属性引用的值）最大长度为 65535 个字符，它是由 CONSTANT_Utf8_info 结构的 16 位无符号 length 项决定。需要注意的是，这里的限制是已编码字符串的字节数量而不是被编码的字符数量。UTF-8 一般用两个或三个字节来编码字符，因此，当字符串中包含多字节字符时，会受到更大的约束。

### 22. 虚拟机启动

Java 虚拟机的启动是通过引导类加载器（Bootstrap Class Loader ）创建一个初始类（Initial Class）来完成，这个类是由虚拟机的具体实现指定。

紧接着，Java 虚拟机链接这个初始类，初始化并调用它的 public void main(String[])方法。之后的整个执行过程都是由对此方法的调用开始。执行 main 方法中的 Java 虚拟机指令可能会导致 Java 虚拟机链接另外的一些类或接口，也可能会调用另外的方法。

可能在某种 Java 虚拟机的实现上，初始类会作为命令行参数被提供给虚拟机。当然，虚拟机实现也可以利用一个初始类让类加载器依次加载整个应用。

初始类当然也可以选择组合上述的方式来工作。

### 23. 验证

验证（Verification）阶段用于确保类或接口的二进制表示结构上是正确的验证过程可能会导致某些额外的类和接口被加载进来，但不应该会导致它们也需要验证或准备。

### 24. 准备

准备（Preparation）阶段的任务是为类或接口的静态字段分配空间，并用默认值初始化这些字段。这个阶段不会执行任何的虚拟机字节码指令。

### 25. 解析

Java 虚拟机指令 anewarray、checkcast、getfield、getstatic、instanceof、nvokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield 和 putstatic 将符号引用指向运行时常量池。执行上述任何一条指令都需要对它的符号引用的进行解析。

解析（Resolution）是根据运行时常量池的符号引用来动态决定具体的值的过程。

### 26. 初始化

初始化（Initialization）对于类或接口来说，就是执行它的初始化方法。

在类或接口被初始化之前，它必须被链接过，也就是经过验证、准备阶段，且有可能已经被解析完成了。

### 27. Java 虚拟机退出

Java 虚拟机的退出条件一般是：某些线程调用 Runtime 类或 System 类的 exit 方法，或是 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这些 exit 或 halt 操作。

除此之外，在 JNI（Java Native Interface）规范中还描述了当使用 JNI API 来加载和卸载（Load & Unload）Java 虚拟机时，Java 虚拟机的退出过程。

### 28. 保留操作码

保留操作码是被 Java 虚拟机内部使用的。如果 Java 虚拟机指令集在将来被扩充的话，这 3 个保留操作码需要保证不被占用。

其中，操作码值分别为 254（0xfe）和 255（0xff），助记符分别为 impdep1 和 impdep2 的两个操作码是作为“后门”和“陷阱”出现，目的是在某些硬件和软件中提供一些与实现相关的功能。第三个操作码值分别为 202（0xca）、助记符为 breakpoint 的操作码是用于调试器实现断点功能。
